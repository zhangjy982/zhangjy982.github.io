<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俊余的博客</title>
  
  <subtitle>东北师范大学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ijunyu.top/"/>
  <updated>2019-03-10T07:54:50.457Z</updated>
  <id>http://blog.ijunyu.top/</id>
  
  <author>
    <name>Junyu Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用C++ Boost库将C++项目封装为Python模块</title>
    <link href="http://blog.ijunyu.top/2019/03/10/boostPython/"/>
    <id>http://blog.ijunyu.top/2019/03/10/boostPython/</id>
    <published>2019-03-10T07:45:37.000Z</published>
    <updated>2019-03-10T07:54:50.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用C-Boost将C-代码封装为Python模块"><a href="#利用C-Boost将C-代码封装为Python模块" class="headerlink" title="利用C++ Boost将C++代码封装为Python模块"></a>利用C++ Boost将C++代码封装为Python模块</h1><p>最近刚做完一个将整个工程集成为一个python模块的工作，使用到的是C++的一个扩展库Boost.Python，它可以将C++代码快捷的移植到Python模块中，实现对Python模块的扩充，下面将详细介绍一下操作流程。</p><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><ul><li>CentOS Linux release 7.6.1810 (Core)</li><li>Python 3.7(Anaconda3)</li><li>GCC 4.9.3</li><li>Boost 1.69.0</li></ul><h2 id="2-安装Boost"><a href="#2-安装Boost" class="headerlink" title="2.安装Boost"></a>2.安装Boost</h2><h3 id="1-下载boost安装包并解压缩"><a href="#1-下载boost安装包并解压缩" class="headerlink" title="(1).下载boost安装包并解压缩"></a>(1).下载boost安装包并解压缩</h3><p>下载：<br><code>wget https://dl.bintray.com/boostorg/release/1.69.0/source/boost_1_69_0.tar.gz</code><br>解压缩：<br><code>tar -xzvf boost_1_69_0.tar.gz</code></p><h3 id="2-设置编译器和所选库"><a href="#2-设置编译器和所选库" class="headerlink" title="(2).设置编译器和所选库"></a>(2).设置编译器和所选库</h3><p>进入解压缩后的目录：<br><code>cd boost_1_69_0</code><br>运行bootstrap.sh脚本并设置相关参数：<br><code>./bootstrap.sh --with-libraries=all --with-toolset=gcc</code><br>其中<code>--with-libraries</code>指定编译哪些boost库，这里方便起见使用<code>all</code>全部编译，如果只想编译部分库就把库名称写上，之间用”,”间隔开就可以，可指定的库可以参考boost官方文档；<code>--with-toolset</code>指定编译时使用哪种编译器，这里使用的是gcc，如果系统中安装了多个版本的gcc，在这里可以指定gcc的版本，例如<code>--with-toolset=gcc-4.8.5</code>。</p><h3 id="3-编译boost"><a href="#3-编译boost" class="headerlink" title="(3).编译boost"></a>(3).编译boost</h3><p>执行以下命令进行boost的编译：<br><code>./b2 toolset=gcc</code><br>编译时间可能会很久，编译过程中可能会出现的问题：<br>提示找不到pyconfig.h:<br><code>/boost/python/detail/wrap_python.hpp:50:23: fatal error: pyconfig.h No such file or directory</code><br>这是因为boost的原生错误，需要修改安装脚本<code>python.jam</code>，该文件的位置在<code>boost_1_69_0/tools/build/src/tools/python.jam</code>，在547行附近将代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    includes ?= $(prefix)/include/python$(version) ;</span><br><span class="line"></span><br><span class="line">    local lib = $(exec-prefix)/lib ;</span><br><span class="line">    libraries ?= $(lib)/python$(version)/config $(lib) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改为：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    includes ?= $(prefix)/include/python$(version)m ;</span><br><span class="line"></span><br><span class="line">    local lib = $(exec-prefix)/lib ;</span><br><span class="line">    libraries ?= $(lib)/python$(version)/config $(lib) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则编译成功，问题解决；  </p><h3 id="4-安装boost"><a href="#4-安装boost" class="headerlink" title="(4).安装boost"></a>(4).安装boost</h3><p>最后执行以下命令开始安装boost：<br><code>./b2 install --prefix=/usr</code><br><code>./b2 install --prefix=/usr</code>用来指定boost的安装目录，如果不加此参数默认的头文件在<code>/usr/local/include/boost</code>目录下，库文件在<code>/usr/local/lib/</code>目录下，这里通过把安装目录指定为<code>--prefix=/usr</code>则boost会直接安装到系统头文件目录和库文件目录下，可以省略配置环境变量过程；</p><p>最后需要注意，如果安装后马上想使用boost库进行编译，还需要执行以下命令来更新一下系统的动态链接库：<br><code>ldconfig</code></p><h2 id="3-使用boost-Python进行转换"><a href="#3-使用boost-Python进行转换" class="headerlink" title="3.使用boost.Python进行转换"></a>3.使用boost.Python进行转换</h2><h3 id="1-一个简单的例子-Hello-World"><a href="#1-一个简单的例子-Hello-World" class="headerlink" title="(1)一个简单的例子(Hello World)"></a>(1)一个简单的例子(Hello World)</h3><p>用C++实现一个模块，在Python中调用时，可以返回一个特定的字符串，以下为hello.cpp代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">greet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, boost"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_PYTHON_MODULE(hello_boostpy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::python;</span><br><span class="line">    def(<span class="string">"greet"</span>, greet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中定义了一个函数<code>greet()</code>，而<code>BOOST_PYTHON_MODULE(hello_boostpy)</code>中的<code>hello_boostpy</code>为模块名称，<code>def</code>中的第一个参数表示在Python中调用<code>greet()</code>时使用的名称，第二个参数对应代码中定义的<code>greet()</code>函数；</p><p>接下来就是将hello.cpp编译成动态链接库的形式：<br><code>g++ -shared -fPIC -o hello_boostpy.so -I /root/anaconda3/lib/python3.7 hello.cpp -lboostpython</code><br>其中<code>-I /root/anaconda3/lib/python3.7</code>是系统中Python的安装位置；</p><p>接下来就可以在Python中使用刚刚生成的<code>hello_boostpy</code>库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello_boostpy <span class="keyword">as</span> hb</span><br><span class="line">hb.greet()</span><br></pre></td></tr></table></figure><p>就可以输出<code>hello boost</code>字符串内容了。</p><h3 id="2-复杂类型转换"><a href="#2-复杂类型转换" class="headerlink" title="(2).复杂类型转换"></a>(2).复杂类型转换</h3><p>将C++扩展为Python模块，即需要把C++封装成Python可以理解的类型，通过使用C++实现测试激励的内部逻辑，然后Python调用C++的这个实现函数即可，这样可以大大减轻脚本编写的速度以及复杂度，例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python/module.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python/def.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python/to_python_converter.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::python;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HelloPython&#123;</span><br><span class="line"><span class="comment">// 简单函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello from boost::python"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HelloClass(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name):name(name)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello from HelloClass by : "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 接受该类的简单函数 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sayHelloClass</span><span class="params">(HelloClass&amp; hello)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello.sayHello() + <span class="string">" in function sayHelloClass"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STL容器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有默认参数值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">(<span class="built_in">string</span> name,<span class="keyword">int</span> age=<span class="number">30</span>,<span class="built_in">string</span> nationality=<span class="string">"China"</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="string">" "</span> &lt;&lt; nationality &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装带有默认参数值的函数</span></span><br><span class="line">BOOST_PYTHON_FUNCTION_OVERLOADS(showPerson_overloads,showPerson,<span class="number">1</span>,<span class="number">3</span>) <span class="comment">//1:最少参数个数,3最大参数个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装模块</span></span><br><span class="line">BOOST_PYTHON_MODULE(HelloPython)&#123;</span><br><span class="line">    <span class="comment">// 封装简单函数</span></span><br><span class="line">    def(<span class="string">"sayHello"</span>,sayHello);</span><br><span class="line">    <span class="comment">// 封装简单类，并定义__init__函数</span></span><br><span class="line">    class_(<span class="string">"HelloClass"</span>,init())</span><br><span class="line">      .def(<span class="string">"sayHello"</span>,&amp;HelloClass::sayHello)<span class="comment">//Add a regular member function</span></span><br><span class="line">      ;</span><br><span class="line">    def(<span class="string">"sayHelloClass"</span>,sayHelloClass); <span class="comment">// sayHelloClass can be made a member of module!!!</span></span><br><span class="line">    <span class="comment">// STL的简单封装方法</span></span><br><span class="line">    class_(<span class="string">"ivector"</span>)</span><br><span class="line">      .def(vector_indexing_suite());</span><br><span class="line">    class_ &gt;(<span class="string">"ivector_vector"</span>)</span><br><span class="line">      .def(vector_indexing_suite &gt;());</span><br><span class="line">    <span class="comment">// 带有默认参数值的封装方法</span></span><br><span class="line">    def(<span class="string">"showPerson"</span>,showPerson,showPerson_overloads());</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/lianchenglian/article/details/77945499" target="_blank" rel="noopener">https://blog.csdn.net/lianchenglian/article/details/77945499</a><br><a href="https://blog.csdn.net/this_capslock/article/details/47170313" target="_blank" rel="noopener">https://blog.csdn.net/this_capslock/article/details/47170313</a><br><a href="https://www.boost.org/doc/libs/1_69_0/libs/python/doc/html/index.html" target="_blank" rel="noopener">https://www.boost.org/doc/libs/1_69_0/libs/python/doc/html/index.html</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用C-Boost将C-代码封装为Python模块&quot;&gt;&lt;a href=&quot;#利用C-Boost将C-代码封装为Python模块&quot; class=&quot;headerlink&quot; title=&quot;利用C++ Boost将C++代码封装为Python模块&quot;&gt;&lt;/a&gt;利用C++ Bo
      
    
    </summary>
    
    
      <category term="C++" scheme="http://blog.ijunyu.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>TensorRT_Document</title>
    <link href="http://blog.ijunyu.top/2019/02/27/TensorRT-Document/"/>
    <id>http://blog.ijunyu.top/2019/02/27/TensorRT-Document/</id>
    <published>2019-02-27T11:32:19.000Z</published>
    <updated>2019-02-27T11:46:43.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TensorRT开发者手册"><a href="#TensorRT开发者手册" class="headerlink" title="TensorRT开发者手册"></a>TensorRT开发者手册</h1><h2 id="1-什么是TensorRT？"><a href="#1-什么是TensorRT？" class="headerlink" title="1.什么是TensorRT？"></a>1.什么是TensorRT？</h2><p>TensorRT源程序是一个能提高英伟达GPU（Griphics processing units）推理性能的C++库。它与TensorFlow、Caffe、PyTorch、MXNet等训练框架相辅相成。它更加关注在GPU上快速高效地运行一个已经存在的学习网络，这个学习网络的目标是生成一个结果（在许多地方也称为得分、检测、回归或推理的过程）。</p><p>一些训练框架类似于tensorflow已经集成了TensorRT，所以TensorRT能够被用来加速框架中的推理过程。作为一种选择，TensorRT可以用作用户应用程序中的库。它包含了很多解析器，这些解析器可以从Caffe、ONNX或者tensorflow中解析已经存在的模型，还可以用于以编程方式构建模型的c++和Python api。</p><p><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/overview.png" alt="avatar"><br>图1：TensorRT是用于产品部署的高性能神经网络推理优化器和运行时引擎</p><p>TensorRT通过合并层和优化核选择来优化网络结构，以达到改善延迟、吞吐量、功率效率和内存消耗。如果应用程序指定，TensorRT还将优化网络以降低运行精度，进一步提高性能和减少内存需求。</p><p>下面的图展示了TensorRT被定义为部分高性能推理优化器和部分运行时引擎。它可以接收在这些流行框架上训练的神经网络，优化神经网络计算，生成一个轻量级运行时引擎（你唯一需要部署到你产品环境中的东西）。然后它还会最大化在这些GPU平台上的吞吐量、降低延迟、增强表现。</p><p><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/whatistrt2.png" alt="avatar"><br>图2：TensorRT是一个可编码的推理加速器</p><p>TensorRT API包含了最通用的深度学习层的实现。关于层的更多信息，请参阅<a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#layers" target="_blank" rel="noopener">TensorRT Layers</a>.你也可以使用<a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/c_api/classnvinfer1_1_1_i_plugin.html" target="_blank" rel="noopener">C++ Plugin API</a>或者<a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/python_api/infer/Plugin/pyPlugin.html" target="_blank" rel="noopener">Python Plugin API</a>来实现不常用或者最新的层，这些层暂时还不被TensorRT所支持。</p><h3 id="1-1-TensorRT的优势"><a href="#1-1-TensorRT的优势" class="headerlink" title="1.1 TensorRT的优势"></a>1.1 TensorRT的优势</h3><p>当神经网络被训练完成后，TensorRT可以压缩、优化这些网络，还可以部署成一个运行环境而不用承担整个框架的总开销。</p><p>TensorRT组合各个层，优化内核选择，还根据指定的精度（FP32、FP16或INT8）执行规范化和优化矩阵转换来改善延迟、吞吐量和效率。</p><p>对于深度学习推理，有5个用于衡量软件的关键指标：  </p><ul><li>吞吐量（Throuthput）：  指定时间区间内的输出量，通常用inference/second 或者samples/second来度量；  </li><li>效率（Efficiency）：单位功率的吞吐量，通常用performance/watt来度量；</li><li>延迟（Latency）：运行推理的时间，通常用ms度量；</li><li>精确度（Accuracy）：训练过的神经网络给出正确结果的能力；</li><li>内存占用（Memory usage）：主机和设备内存决定于所用的神经网络算法需要申请多少内存空间进行推理；  </li></ul><p>使用TensorRT的可选方案包括：</p><ul><li>使用训练框架本身进行推理；</li><li>写一个使用低层库和数学操作的专门用来执行特定网络的自定义应用程序；</li></ul><p>使用训练框架执行推理很容易，但是在给定的额GPU上，与使用推理优化方案相比，性能会低很多。训练框架倾向于实现更加通用的代码，当优化时，优化往往集中在有效的训练上；<br>自定义程序编写可以获得更高的效率，但是对开发人员知识技能要求非常高，而且针对一个GPU的优化无法完全转移到另一个型号不同的GPU上，因而开发成本非常高；<br>而TensorRT通过将API与特定硬件细节的高级抽象结合来解决这些问题，可以提高吞吐量、降低延迟、并尽可能降低内存占用。  </p><h4 id="1-1-1-谁能够从TensorRT中获益？"><a href="#1-1-1-谁能够从TensorRT中获益？" class="headerlink" title="1.1.1 谁能够从TensorRT中获益？"></a>1.1.1 谁能够从TensorRT中获益？</h4><p>TensorRT的目标用户是负责基于新的或现有的深度学习模型构建特征和应用程序，或将模型部署到生产环境中的工程师。这些部署可能部署到数据中心或云中的服务器、嵌入式设备、机器人或车辆中，或将在用户工作站上运行的应用程序软件中。</p><p>TensorRT已经成功地应用于各种场景，包括:</p><ul><li>Robots：公司销售的机器人使用TensorRT运行各种计算机视觉模型，在动态环境中自动引导无人机系统飞行；</li><li>Autonomous Vehicles：TensorRT被用于为NVIDIA驱动产品的计算机视觉提供支持；</li><li>Scientific and Technical Computing：一种流行的技术计算包嵌入TensorRT以支持神经网络模型的高吞吐量执行；</li><li>Deep Learning Training and Deployment Frameworks：TensorRT在几个有名的深度学习框架比如<a href="https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/" target="_blank" rel="noopener">TensorFlow</a>和<a href="https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/mxnet/" target="_blank" rel="noopener">MXNet</a>中都被包含；</li><li>Video Analytics：TensorRT被应用于英伟达的<a href="https://developer.nvidia.com/deepstream-sdk" target="_blank" rel="noopener">DeepStream</a>产品中，为复杂的视频分析提供解决方案；</li><li>Automatic Speech Recognition：TensorRT用于小型桌面设备上的语音识别。该设备支持有限的词汇量，云计算中提供了更大的词汇量语音识别系统。</li></ul><h3 id="1-2-TensorRT适用于哪里？"><a href="#1-2-TensorRT适用于哪里？" class="headerlink" title="1.2 TensorRT适用于哪里？"></a>1.2 TensorRT适用于哪里？</h3><p>通常情况下，开发和部署深度学习模型的工作流经历三个阶段：</p><ul><li>阶段1：训练；</li><li>阶段2：提出部署方案；</li><li>阶段3：执行部署方案；</li></ul><h4 id="阶段1：训练"><a href="#阶段1：训练" class="headerlink" title="阶段1：训练"></a>阶段1：训练</h4><p>在整个训练阶段，数据科学家和开发者根据他们想解决的问题选择精确的输入输出和损失函数。他们还将收集、管理、扩充、甚至可能标记培训、测试和验证数据集。他们会设计网络结构并且训练模型。在训练过程中，他们将监控学习过程，学习过程可能会提供反馈，从而使他们修正损失函数，获取或增加培训数据。在这个流程的最后，他们会验证模型表现并保存模型。训练和验证通常使用Titano或者Tesla datacenter GPU。在这一阶段通常不会用到TensorRT。</p><h4 id="阶段2：提出部署方案"><a href="#阶段2：提出部署方案" class="headerlink" title="阶段2：提出部署方案"></a>阶段2：提出部署方案</h4><p>在第二个阶段，数据科学家和开发人员将从训练过的模型开始，并使用这个训练过的模型创建和验证部署解决方案。把这个阶段分解成几个步骤，如下：</p><p>1.考虑神经网络是如何在它所处的大系统中工作的，并设计和实现一个合适的解决方案，可能包含神经网络的系统的范围非常广泛。例如：</p><ul><li>交通工具中的自动驾驶系统；</li><li>公共场所或公司校园的视频安全系统；</li><li>消费者设备的语音接口；</li><li>工业生产线自动化质量保证系统；</li><li>提供产品推荐的在线零售系统；</li><li>提供娱乐过滤器的消费者web服务；</li></ul><p>决定好你的优先级，考虑到可以实现的不同系统的多样性，在设计和实现部署体系结构时可能需要考虑很多事情：</p><ul><li>你有一个单独的网络还是许多网络？例如，你是否基于一个单一的网络（人脸识别）开发一个特征或系统？你的系统会不会由混合的、附加的或者不同的模型组成？也许是提供最终用户可能提供的集合模型的更通用的工具?</li><li>你使用什么设备或者计算工具来运行网络？是CPU/GPU还是其他，或者二者结合？是不是只有一种类型的GPU？是否需要设计一个应用程序可以运行在不同种类的GPU上？</li><li>数据怎样加载到模型？什么是数据管道？数据是来自相机、传感器还是一系列的文件？</li><li>需要怎样的延迟和吞吐量？</li><li>你能把很多需求进行批处理吗？</li><li>你需要单个网络的多个实例来实现所需的总体系统吞吐量和延迟吗?</li><li>你会如何处理网络输出？</li><li>需要哪些后处理步骤？</li></ul><p>TensorRT提供了一个快速、模块化、紧凑、健壮、可靠的推理引擎，可以支持部署体系结构中的推理需求。</p><p>2.数据科学家和开发者定义完推理解决方案的结构，也就是决定了他们的优先级之后，接下来他们使用TensorRT从已保存的模型中创建一个推理引擎。根据所使用的培训框架和网络体系结构，有许多方法可以做到这一点。通常来说，这意味着你需要拿到训练过的神经网络并且使用ONNX解析器、Caffe解析器或者TensorFlow/UFF解析器将原格式解析为TensorRT支持的格式。如下图：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/fit1.png" alt="avatar"><br>图三：ONNX 工作流 V1</p><p>3.当网络被解析以后，你就需要考虑优化选项——batch size，workspace size，mixed precision。选择并指定这些选项作为TensorRT构建步骤的一部分，在该步骤中，您将实际构建基于网络的优化推理引擎。本指南的后续部分提供了关于工作流这一部分的详细说明和大量示例，将您的模型解析为TensorRT并选择优化参数，如图4所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/fit.png" alt="avatar"><br>图四：TensorRT优化训练过的神经网络模型，以生成可部署的运行时推理引擎。</p><p>4.当你已经使用TensorRT创建好一个推理引擎之后，你会想验证一下推理结果和训练中的结果是否一致。如果你选择了FP32或FP16，那么结果应该非常接近。如果你选择了INT8，那么在训练中获得的准确率和推理准确率之间可能会有一个小的差距。</p><p>5.以序列化格式写出推理引擎，这也称为计划文件。</p><h4 id="阶段三：执行部署方案"><a href="#阶段三：执行部署方案" class="headerlink" title="阶段三：执行部署方案"></a>阶段三：执行部署方案</h4><p>TensorRT库链接到部署的应用程序，该应用程序在需要推理结果时调用库。为了初始化推理引擎，应用程序首先要将模型从计划文件反序列化为推理引擎。</p><p>TensorRT通常情况下是异步使用的，所以，当输入数据到达时，程序调用enqueue函数并传入输入缓冲区和输出缓冲区的指针地址。</p><h3 id="1-3-TensorRT是如何工作的？"><a href="#1-3-TensorRT是如何工作的？" class="headerlink" title="1.3 TensorRT是如何工作的？"></a>1.3 TensorRT是如何工作的？</h3><p>为了优化推理引擎，TensorRT会接收你的网络定义，执行包括特定平台优化在内的优化然后生成推理引擎，这个过程称为构建阶段。构建阶段可能需要相当长的时间，尤其是在嵌入式平台上运行的时候。因此，典型的应用程序将构建一次引擎，然后将其序列化为计划文件供以后使用。</p><p>NOTE:生成的计划文件不能跨平台或TensorRT版本移植。计划是特定于它们所构建的精确GPU模型的(除了平台和TensorRT版本之外)，如果您想在不同的GPU上运行它们，则必须针对特定的GPU重新制定计划。</p><p>构建阶段对层图执行以下优化:</p><ul><li>消除输出未被使用的层；</li><li>融合convolution，bias和ReLU operations；</li><li>聚合具有足够相似参数和相同源张量的operations，例如在GoogleNet v5中初始模块中的1*1卷积；</li><li>通过非拷贝方式将层输出定向到正确的最终地址来合并连接层；</li></ul><p>如有必要，构建过程也可以改变权重的精度。当生成8-bit整数精度的网络时，TensorRT使用一个叫做calibration的进程来决定中间激活的动态范围，并因此确定用于量化的适当缩放因子。  </p><p>另外，构建阶段还在虚拟数据上运行层，以便从其内核目录中选择最快的层，并在适当的情况下执行权重预格式化和内存优化。</p><h3 id="1-4-TensorRT核心API"><a href="#1-4-TensorRT核心API" class="headerlink" title="1.4 TensorRT核心API"></a>1.4 TensorRT核心API</h3><p>TensorRT让开发者们能够import/calibrate/generate and deploy optimized networks。网络结构能直接通过Caffe导入，也可以通过uff或ONNX等格式从其他框架导入。  </p><p>TensorRT核心库中的关键接口是：</p><ul><li>网络定义（Network Definition）：网络定义接口提供了应用程序指定网络定义的方法。可以指定输入输出张量，可以添加层，还有用于配置每种支持的层类型的接口。除了层类型（例如卷积层或循环层）之外，插件层类型还可以使应用程序实现TensorRT本身并不支持的功能。  </li><li>生成器（Builder）：生成器接口允许通过网络定义建立优化引擎。它允许应用程序指定最大批次大小、工作空间大小、最低可接受精度级别、自动调整的校准迭代次数，以及用于INT8量化的接口。</li><li>引擎（Engine)：引擎接口允许应用程序执行推理，支持同步和异步支持、分析、枚举和查询绑定缓冲区信息，即引擎输入和输出。单个引擎可以具有多个执行上下文，允许一组训练参数用于同时执行多个批次。</li></ul><p>同时，TensorRT还提供解析器，用于导入经过训练的网络来创建网络定义：</p><ul><li>Caffe Parser：此解析器可用于解析在BVLV Caffe或NVCaffe中创建的Caffe网络；</li><li>Uff Parser：此解析器用于UFF格式的解析网络；</li><li>ONNX Parser：此解析器可用于解析ONNX模型；</li></ul><h2 id="2-使用C-API与TensorRT一起工作"><a href="#2-使用C-API与TensorRT一起工作" class="headerlink" title="2.使用C++ API与TensorRT一起工作"></a>2.使用C++ API与TensorRT一起工作</h2><p>本章内容：</p><ul><li>从模型中创建TensorRT网络定义；</li><li>调用TensorRT构建器从网络创建优化的运行时引擎；</li><li>序列化和反序列化引擎，以便在运行时快速重新创建它；</li><li>向引擎提供数据以执行推理；</li></ul><h3 id="2-1-在C-中实例化TensorRT对象"><a href="#2-1-在C-中实例化TensorRT对象" class="headerlink" title="2.1 在C++中实例化TensorRT对象"></a>2.1 在C++中实例化TensorRT对象</h3><p>为了运行推理，你需要使用<code>IExecutionContext</code>对象。为了创建一个<code>IExecutionContext</code>对象，你首先需要创建一个<code>iICudaEngine</code>类型的对象（也就是引擎）。<br>引擎可以通过以下两种方法构建：</p><ul><li>从用户模型中的网络定义。在这种情况下，可以选择序列化引擎，并将其保存以供以后使用；</li><li>通过从磁盘读取序列化引擎。在这种情况下，由于绕过了解析模型和创建中间对象的步骤，所以性能更好；</li></ul><p><code>ILogger</code>类型的对象需要全局创建,它被用作TensorRT API的各种方法的参数。下面是一个简单的示例，演示如何创建日志记录器:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> :</span> <span class="keyword">public</span> ILogger</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(Severity severity, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span> override</span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">// suppress info-level messages</span></span><br><span class="line">         <span class="keyword">if</span> (severity != Severity::kINFO)</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; gLogger;</span><br></pre></td></tr></table></figure><p>一个叫做<code>createInferBuilder(gLogger)</code>的全局TensorRT API方法被用作创建<code>iBuilder</code>类型的对象，如图5所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/ibuildilog.PNG" alt="avatar"><br>图五：使用<code>iLogger</code>作为参数创建<code>iBuilder</code>.  </p><p>为<code>iBuilder</code>定义的<code>createNetwork</code>方法用于创建<code>iNetworkDefinition</code>类型的对象,如图6所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/createnet.PNG" alt="avatar"><br>图六：<code>createNetwork()</code>被用来创建网络。  </p><p>其中一个可用的解析器是使用<code>iNetworkDefinition</code>作为输入创建的: </p><ul><li>ONNX: &emsp;<code>parser = nvonnxparser::createParser(*network, gLogger);</code></li><li>NVCaffe: &emsp;<code>ICaffeParser* parser = createCaffeParser();</code></li><li>UFF: &emsp;<code>parser = createUffParser();</code></li></ul><p>调用类型<code>iParser</code>的对象中的<code>parse()</code>方法来读取模型文件并填充TensorRT网络,如图7所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/iparser.PNG" alt="avatar"><br>图七：解析模型文件  </p><p>调用<code>iBuilder</code>的<code>buildCudaEngine()</code>方法来创建<code>iCudaEngine</code>类型的对象,如图8所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/iengine.PNG" alt="avatar"><br>图八：创建TensorRT引擎。  </p><p>可以选择序列化引擎并将其转储到文件中，如图9所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/serialengine.PNG" alt="avatar"><br>图九：创建TensorRT引擎。  </p><p>执行上下文用于执行推理，如图10所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/createcontext.PNG" alt="avatar"><br>图十：创建执行上下文。  </p><p>一个名为<code>createInferRuntime(gLogger)</code>的全局TensorRT API方法用于创建<code>iRuntime</code>类型的对象,如图11所示：<br><img src="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/graphics/createruntime.PNG" alt="avatar"><br>图十一：创建TensorRT runtime  </p><p>更多关于TensorRT的信息请参见<a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-api/c_api/classnvinfer1_1_1_i_runtime.html" target="_blank" rel="noopener">IRuntime class reference</a>。该引擎是通过调用运行时方法<code>deserializeCudaEngine()</code>创建的。对于这两个使用模型，推论的其余部分是相同的。</p><p>尽管可以避免创建CUDA上下文(将为你创建默认上下文)，但这是不可取的。<br>建议在创建运行时或构建器对象之前创建和配置CUDA上下文。</p><p>构建器或运行时将使用与创建线程关联的GPU上下文创建。虽然如果还不存在缺省上下文，将创建它，但是建议在创建运行时或构建器对象之前创建和配置CUDA上下文。</p><h3 id="2-2-用C-创建网络定义"><a href="#2-2-用C-创建网络定义" class="headerlink" title="2.2 用C++创建网络定义"></a>2.2 用C++创建网络定义</h3><p>执行TensorRT推理的第一步是从你的模型创建一个TensorRT网络。实现这一目标最简单的方法就是使用TensorRT parser library，这个库支持下面这些格式模型的序列化：  </p><ul><li><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#mnist_sample" target="_blank" rel="noopener">sampleMNIST</a>(BVLC和NVCaffe)；</li><li><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#onnx_mnist_sample" target="_blank" rel="noopener">sampleOnnxMNIST</a>;</li><li><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-developer-guide/index.html#mnist_uff_sample" target="_blank" rel="noopener">sampleUffMNIST</a>(TensorFlow);</li></ul><p>另一个可选的办法是直接使用TensorRT API定义模型。这样的话就要求进行少量的API调用来定义网络图中的每一层，并为模型的训练参数实现你自己的导入机制。</p><p>在另一种情况下，你需要显式地告诉TensorRT哪些张量是推理输出所必需的，没有标记为输出的张量被认为是可能被构建器优化掉的临时值。输出张量的数量没有限制，然而，将张量标记为输出可能会禁止对该张量进行某些优化。还必须为输入和输出张量指定名称（使用<code>ITensor::setName()</code>）。在推理时，你将为引擎提供一个指向输入和输出缓冲区的指针数组。为了确定引擎期望这些指针的顺序，可以使用张量名称进行查询。</p><p>TensorRT网络定义的一个重要方面是，它包含指向模型权重的指针，构建器将这些指针复制到优化的引擎中。如果通过解析器创建网络，那么解析器将拥有权重占用的内存，因此在构建器运行之前不应该删除解析器对象。</p><h4 id="2-2-1-使用C-UFF解析器API导入TensorFlow模型"><a href="#2-2-1-使用C-UFF解析器API导入TensorFlow模型" class="headerlink" title="2.2.1 使用C++ UFF解析器API导入TensorFlow模型"></a>2.2.1 使用C++ UFF解析器API导入TensorFlow模型</h4><p>NOTE:对于新项目来说，建议使用TensorFlow-TensorRT集成作为将TensorFlow网络转换为使用TensorRT进行推理的方法。</p><p>从TensorFlow框架导入需要将TensorFlow模型转换为中间格式UFF(通用框架格式)。下面是转换的方法：  </p><p>可以使用下面这段简单的代码转换后缀<code>.pb</code>的冻结图为<code>.uff</code>格式：<br><code>convert-to-uff input_file [-o output_file] [-O output_node]</code><br>列出TensorFlow中的层：<br><code>convert-to-uff input_file -l</code>  </p><p>下面的步骤演示了如何使用C++解析器API导入TensorFlow模型:  </p><p>1.构建 <code>builder</code>和<code>network</code>：<br><code>IBuilder* builder = createInferBuilder(gLogger);</code><br><code>INetworkDefinition* network = builder-&gt;createNetwork();</code>  </p><p>2.构建UFF解析器：<br><code>IUFFParser* parser = createUffParser();</code>  </p><p>3.向UFF解析器声明网络输入和输出:<br><code>parser-&gt;registerInput(&quot;Input_0&quot;, DimsCHW(1, 28, 28), UffInputOrder::kNCHW);</code><br><code>parser-&gt;registerOutput(&quot;Binary_3&quot;);</code><br>NOTE:TensorRT期望输入张量是CHW格式的。从TensorFlow导入时，确保输入张量的顺序是符合要求的，如果不是，则将其转换为CHW。</p><p>4.解析导入的模型来填充网络:<br><code>parser-&gt;parse(uffFile, *network, nvinfer1::DataType::kFLOAT);</code></p><h3 id="2-3-用C-构造引擎"><a href="#2-3-用C-构造引擎" class="headerlink" title="2.3 用C++构造引擎"></a>2.3 用C++构造引擎</h3><p>接下来的步骤是调用TensorRT构建器来创建优化的runtime。构建器的功能之一是在CUDA内核目录中搜索可用的最快实现，因此必须使用与优化引擎将要运行的相同的GPU进行构建。<br>构造器有很多属性，你可以按照顺序设置它们以便控制网络运行中诸如精度等信息，并且自动调谐参数，例如，当确定哪一次是最快的时候，TensorRT应该测定每一个内核的时间（更多的迭代导致更长时间的运行时，但更易受到噪声影响）。<br>你也可以通过查询构造器来了解硬件本地支持哪些降低的精度类型。  </p><p>两个特别重要的属性是最大批处理大小和最大工作区大小：</p><ul><li>最大批处理大小指定TensorRT要优化的批大小，在运行时，可以选择较小的批处理大小；  </li><li>层算法通常需要临时工作区，此参数限制网络中任何层可以使用的最大工作区大小。如果提供的空间不够，TensorRT可能无法找到给定层的实现；</li></ul><p>1.使用builder对象构建引擎:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder-&gt;setMaxBatchSize(maxBatchSize);</span><br><span class="line">builder-&gt;setMaxWorkspaceSize(<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">ICudaEngine* engine = builder-&gt;buildCudaEngine(*network);</span><br></pre></td></tr></table></figure><p>当引擎被构造出来时，TensorRT会复制权重。</p><p>2.如果只需要network、builder、parser中的一个时，可以销毁其他：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">engine-&gt;destroy();</span><br><span class="line">network-&gt;destroy();</span><br><span class="line">builder-&gt;destroy();</span><br></pre></td></tr></table></figure><h3 id="2-4-使用C-序列化一个模型"><a href="#2-4-使用C-序列化一个模型" class="headerlink" title="2.4 使用C++序列化一个模型"></a>2.4 使用C++序列化一个模型</h3><p>序列化模型的做法是将引擎转换为一种特殊格式，以便在后续的推理中存储和使用。在执行推理的时候，你可以简单的反序列化这个引擎。序列化和反序列化是可选的。从一个网络定义中构造引擎是很费时的，你可以把它只做一次序列化然后在每次推理的时候将其反序列化，以此来避免每次应用程序重新运行时都要重新构建引擎。因此，在引擎构建好之后，用户通常希望序列化它以供以后使用。<br>在使用模型进行推理之前，并不一定需要对其进行序列化和反序列化——如果需要的话，引擎对象可以直接用于推理。  </p><p>NOTE：序列化引擎不能跨平台或TensorRT版本移植，引擎特定于它们所构建的精确GPU模型(除了平台和TensorRT版本)。</p><p>1.运行builder作为一个提前的脱机运行步骤，然后执行序列化：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IHostMemory *serializedModel = engine-&gt;serialize();</span><br><span class="line"><span class="comment">// store model to disk</span></span><br><span class="line"><span class="comment">// &lt;…&gt;</span></span><br><span class="line">serializedModel-&gt;destroy();</span><br></pre></td></tr></table></figure><p>2.构建一个runtime对象来反序列化：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IRuntime* runtime = createInferRuntime(gLogger);</span><br><span class="line">ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(modelData, modelSize, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>最后一个参数是当应用程序使用自定义层时的插件层工厂，更多详细信息参见使用自定义层拓展TensorRT。</p><h3 id="2-5-使用C-执行推理"><a href="#2-5-使用C-执行推理" class="headerlink" title="2.5 使用C++执行推理"></a>2.5 使用C++执行推理</h3><p>当有一个引擎之后，下面的步骤阐述了如何使用C++执行推理的过程：</p><p>1.创建一些空间来存储中间激活值。由于引擎包含网络定义和训练参数，因此需要额外的空间，它们在执行上下文中保存:  </p><p><code>IExecutionContext *context = engine-&gt;createExecutionContext();</code><br>引擎可以有多个执行上下文，允许一组权重用于多个重叠推理任务。例如，您可以在并行CUDA流中处理图像，每个流使用一个引擎和一个上下文,每个上下文将在与引擎相同的GPU上创建。</p><p>2.使用输入和输出blob名称来获得相应的输入和输出索引:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inputIndex = engine.getBindingIndex(INPUT_BLOB_NAME);</span><br><span class="line"><span class="keyword">int</span> outputIndex = engine.getBindingIndex(OUTPUT_BLOB_NAME);</span><br></pre></td></tr></table></figure><p>3.使用这些索引，设置一个缓冲区数组指向GPU上的输入和输出缓冲区:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* buffers[<span class="number">2</span>];</span><br><span class="line">buffers[inputIndex] = inputbuffer;</span><br><span class="line">buffers[outputIndex] = outputBuffer;</span><br></pre></td></tr></table></figure><p>4.TensorRT的执行通常是异步的，因此将内核排队到CUDA流中:</p><p><code>context.enqueue(batchSize, buffers, stream, nullptr);</code></p><p>通常在内核之前和之后对异步memcpy()进行排队，以便在GPU中还没有数据时将其移动。enqueue()的最后一个参数是一个可选的CUDA事件，当输入缓冲区被使用并且它们的内存可以安全地重用时，将发出信号。<br>要确定内核(可能还有memcpy())什么时候完成，可以使用标准的CUDA同步机制，比如事件，或者等待流。</p><h3 id="2-6-用C-进行内存管理"><a href="#2-6-用C-进行内存管理" class="headerlink" title="2.6 用C++进行内存管理"></a>2.6 用C++进行内存管理</h3><p>TensorRT提供了两种机制，允许应用程序更多地控制设备内存。<br>默认情况下，当创建一个<code>IExecutionContext</code>的时候，会分配持久设备内存以保存激活数据。为了避免这种分配，调用<code>createExecutionContextWithoutDeviceMemory</code>,然后，应用程序负责调用IExecutionContext::setDeviceMemory()来提供运行网络所需的内存,内存块的大小由ICudaEngine::getDeviceMemorySize()返回。<br>此外，通过实现<code>IGpuAllocator</code>接口，应用程序可以提供一个定制的分配器，以便在构建和运行时使用。当接口实现之后，在IBuilder或IRuntime接口上调用<code>setGpuAllocator(&amp;allocator);</code>  。然后，所有设备内存将通过该接口分配和释放。</p><h2 id="3-使用plugin添加TensorRT中对TensorFlow不支持的op"><a href="#3-使用plugin添加TensorRT中对TensorFlow不支持的op" class="headerlink" title="3.使用plugin添加TensorRT中对TensorFlow不支持的op"></a>3.使用plugin添加TensorRT中对TensorFlow不支持的op</h2><h3 id="3-1-通过使用-C-API-添加自定义层"><a href="#3-1-通过使用-C-API-添加自定义层" class="headerlink" title="3.1 通过使用 C++ API 添加自定义层"></a>3.1 通过使用 C++ API 添加自定义层</h3><p>通过继承<code>IPluginV2</code>和<code>IPluginCreator</code>类来实现自定义层。<br><code>IPlugin</code>：<br><code>IPluginV2</code>类是实现plugin的基类，它包括版本控制支持并且能够使自定义层支持包括NCHW和单精度之外的其他数据格式；<br><code>IPluginCreator</code>:<br><code>IPluginCreator</code>类是自定义层的Creator类，用户可以使用它来获取插件名称、版本和插件字段参数。它还提供了在网络构建阶段生成插件对象和在推理中反序列化的方法；  </p><p>TensorRT还提供了通过调用<code>REGISTER_TENSORRT_PLUGIN(pluginCreator)</code>来注册一个plugin的功能，将Plugin Creator通过静态方式注册到Plugin Registry中。在运行过程中，Plugin Registry能够通过外部函数<code>getPluginRegistry()</code>来查询。Plugin Registry中存储了所有注册过的Plugin Creator的指针并且被应用到基于plugin名称和版本的特定Plugin Creator的查找。TensorRT库包含了很多能被加载到应用程序中的plugin。这些plugin的版本被置为1。这些plugin的名称为：  </p><ul><li>RPORT_TRT</li><li>Normalize_TRT</li><li>PriorBox_TRT</li><li>GridAnchor_TRT</li><li>NMS_TRT</li><li>LReLU_TRT</li><li>Reorg_TRT</li><li>Region_TRT</li><li>Clip_TRT</li></ul><p>为了在应用程序中使用TensorRT中已注册的plugins，<code>libnvinfer_plugin.so</code>库必须被加载，并且所有的plugin必须是已注册的。这些能够通过在应用程序代码中调用<code>initLibNvInferPlugins(void* logger, const char* libNamespace)()</code>方法来实现。  </p><p>如果你有你自己的plugin库，你可以包含一个类似的入口指针，将注册表中的所有插件注册到一个唯一的命名空间中。这样可以保证在不同的插件库之间build时没有插件命名冲突。  </p><p>在使用<code>Plugin Creator</code>的时候，<code>IPluginCreator::createPlugin()</code>方法可以返回IPluginV2类型的plugin对象，这个对象可以使用<code>addPluginV2()</code>被添加到TensorRT network中，<code>addPluginV2()</code>的作用就是创建并且添加一个层到网络中，然后把这个层和对应的plugin绑定。这个方法还会返回一个到这个层的指针（类型为<code>IPluginV2Layer</code>）,这一指针可以用来指向该层或者插件本身（通过<code>getPlugin()</code>）；</p><p>举个例子，为了将插件层添加到你的网络中，并把插件名称设置为<code>pluginName</code>,版本设置为<code>pluginVersion</code>，你可以执行如下操作：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Use the extern function getPluginRegistry to access the global TensorRT Plugin Registry</span></span><br><span class="line"><span class="comment">//使用外部函数getPluginRegistry来访问全局TensorRT plugin注册表</span></span><br><span class="line"><span class="keyword">auto</span> creator = getPluginRegistry()-&gt;getPluginCreator(pluginName, pluginVersion);</span><br><span class="line"><span class="keyword">const</span> PluginFieldCollection* pluginFC = creator-&gt;getFieldNames();</span><br><span class="line"><span class="comment">//populate the field parameters (say layerFields) for the plugin layer</span></span><br><span class="line"><span class="comment">//填充插件层的字段参数（比如layerFields）</span></span><br><span class="line">PluginFieldCollection *pluginData = parseAndFillFields(pluginFC, layerFields);</span><br><span class="line"><span class="comment">//create the plugin object using the layerName and the plugin meta data</span></span><br><span class="line"><span class="comment">//使用layerName和plugin meta data来创建plugin对象</span></span><br><span class="line">IPluginV2 *pluginObj = creator-&gt;createPlugin(layerName, pluginData);</span><br><span class="line"><span class="comment">//add the plugin to the TensorRT network using the network API</span></span><br><span class="line"><span class="comment">//使用network API来把plugin添加到TensorRT network中</span></span><br><span class="line"><span class="keyword">auto</span> layer = network.addPluginV2(&amp;inputs[<span class="number">0</span>], <span class="keyword">int</span>(inputs.size()), pluginObj);</span><br><span class="line">… (build rest of the network <span class="keyword">and</span> serialize engine)</span><br><span class="line"><span class="comment">// Destroy the plugin object</span></span><br><span class="line">pluginObj-&gt;destroy()</span><br><span class="line">… (destroy network, engine, builder)</span><br><span class="line">… (<span class="built_in">free</span> allocated pluginData)</span><br></pre></td></tr></table></figure><p>在传递给<code>createPlugin</code>之前，<code>pluginData</code>应该在堆上分配PluginField条目；  </p><p>上面的<code>createPlugin</code>方法将在堆上创建一个新的plugin对象，并返回指向该对象的指针。确保你销毁了plugin对象，就像上面所展示的那样，这样可以避免内存泄漏的问题；  </p><p>在序列化过程中，TensorRT引擎会在内部为所有<code>IPluginV2</code>类型的plugin储存其plugin类型、版本以及命名空间（如果存在的话）。在反序列化过程中，TensorRT引擎会查找这些信息，以便从插件注册表中找到Plugin Creator。这就使TensorRT引擎能够在内部调用<code>IPluginCreator::deserializePlugin()</code>方法。在反序列化过程中创建的插件对象将由TensorRT引擎通过调用<code>IPluginV2::destroy()</code>方法在内部销毁。</p><h3 id="3-2-在c-中为TensorFlow网络添加一个定制的插件层-custom-layer"><a href="#3-2-在c-中为TensorFlow网络添加一个定制的插件层-custom-layer" class="headerlink" title="3.2 在c++中为TensorFlow网络添加一个定制的插件层(custom layer)"></a>3.2 在c++中为TensorFlow网络添加一个定制的插件层(custom layer)</h3><p>（1）.实现<code>IPluginV2</code>和<code>IPluginCreator</code>类；<br>（2）.将TensorFlow操作映射到plugin操作，可以使用<code>graphsurgeon</code>来实现。例如，参考下面的代码片段将TensorFlow Relu6操作映射到一个插件:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> graphsurgeon <span class="keyword">as</span> gs</span><br><span class="line"></span><br><span class="line">lrelu_node = gs.create_plugin_node(name=”trt_lrelu”, op=”LReLU_TRT”,</span><br><span class="line"> negSlope=<span class="number">0.2</span>)</span><br><span class="line">namespace_plugin_map = &#123; “tf_lrelu” : lrelu_node &#125;</span><br><span class="line"><span class="comment"># Transform TensorFlow graph using graphsurgeon and save to UFF</span></span><br><span class="line">dynamic_graph = gs.DynamicGraph(tf_lrelu.graph)</span><br><span class="line">dynamic_graph.collapse_namespaces(namespace_plugin_map)</span><br><span class="line"><span class="comment"># Run UFF converter using new graphdef</span></span><br><span class="line">uff_model = uff.from_tensorflow(dynamic_graph.as_graph_def(), [<span class="string">"trt_lrelu"</span>],</span><br><span class="line"> output_filename=”test_lrelu.uff”, text=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中,<code>tf_lrelu</code>是TensorFlow图中LRelu结点的名称。它通过op <code>LReLU_TRT</code>将tf_lrelu结点映射到一个自定义plugin结点，<code>LReLU_TRT</code>是被使用的plugin的名称。将上面的代码保存为<code>config.py</code>文件。如果plugin层需要参数，它们应该作为参数传递给<code>s.create_plugin_node</code>。</p><p>（3）.调用UFF-converter，设置预处理-p标志:<br><code>convert-to-uff frozen_inference_graph.pb -p config.py -t</code><br>这将生成一个UFF文件，TensorRT plugin结点将替换TensorFlow操作。</p><p>（4）.TensorRT使用UFF解析器运行预处理和转换的UFF文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TensorRT开发者手册&quot;&gt;&lt;a href=&quot;#TensorRT开发者手册&quot; class=&quot;headerlink&quot; title=&quot;TensorRT开发者手册&quot;&gt;&lt;/a&gt;TensorRT开发者手册&lt;/h1&gt;&lt;h2 id=&quot;1-什么是TensorRT？&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="TensorRT" scheme="http://blog.ijunyu.top/tags/TensorRT/"/>
    
  </entry>
  
  <entry>
    <title>PerformanceAnalysis</title>
    <link href="http://blog.ijunyu.top/2018/10/05/PerformanceAnalysis/"/>
    <id>http://blog.ijunyu.top/2018/10/05/PerformanceAnalysis/</id>
    <published>2018-10-05T04:47:30.000Z</published>
    <updated>2018-10-05T08:29:47.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要求0"><a href="#要求0" class="headerlink" title="要求0"></a>要求0</h1><h2 id="第一次运行"><a href="#第一次运行" class="headerlink" title="第一次运行"></a>第一次运行</h2><p>插入exe1</p><h2 id="第二次运行"><a href="#第二次运行" class="headerlink" title="第二次运行"></a>第二次运行</h2><p>插入exe2</p><h2 id="第三次运行"><a href="#第三次运行" class="headerlink" title="第三次运行"></a>第三次运行</h2><p>插入exe3</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>第一次运行时间为： 7.192s<br>第二次运行时间为： 2.273s<br>第三次运行时间为： 2.227s<br>CPU参数： Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz 2.50GHz</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;要求0&quot;&gt;&lt;a href=&quot;#要求0&quot; class=&quot;headerlink&quot; title=&quot;要求0&quot;&gt;&lt;/a&gt;要求0&lt;/h1&gt;&lt;h2 id=&quot;第一次运行&quot;&gt;&lt;a href=&quot;#第一次运行&quot; class=&quot;headerlink&quot; title=&quot;第一次运行&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ijunyu.top/2018/10/05/JilinTour/"/>
    <id>http://blog.ijunyu.top/2018/10/05/JilinTour/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2018-10-20T03:05:46.668Z</updated>
    
    <content type="html"><![CDATA[<p>本作业的要求：[<a href="https://edu.cnblogs.com/campus/nenu/2018fall/homework/2149]" target="_blank" rel="noopener">https://edu.cnblogs.com/campus/nenu/2018fall/homework/2149]</a></p><h1 id="吉林市2日游"><a href="#吉林市2日游" class="headerlink" title="吉林市2日游"></a>吉林市2日游</h1><h2 id="1-出行目的"><a href="#1-出行目的" class="headerlink" title="1.出行目的"></a>1.出行目的</h2><p>增进老师和同学们之间的感情，领略大自然的美景，在闲暇之余放松身心，总而言之就是大家可以玩的开心；</p><h2 id="2-出行时间"><a href="#2-出行时间" class="headerlink" title="2.出行时间"></a>2.出行时间</h2><p>因为有老人和儿童，所以出发时间不适宜太早，加上我们有2天的游玩时间，所以出发时间定在了2018年10月13日8:00；</p><h2 id="3-出行人员"><a href="#3-出行人员" class="headerlink" title="3.出行人员"></a>3.出行人员</h2><h3 id="1-组织人员"><a href="#1-组织人员" class="headerlink" title="(1).组织人员"></a>(1).组织人员</h3><ul><li>总策划：张俊余（负责整个出游活动的安排及策划）；</li><li>安全负责人：付佳（负责解决现场安全问题）</li><li>秩序负责人：公冶令鑫（负责出游过程中提醒大家不要掉队，维持出行秩序）</li><li>景点导游\拍照：王玉潘（到达景点后负责给大家介绍景点，并负责拍摄集体照片）</li><li>公共用品携带：杨磊（负责携带医药箱等公共物品）<h3 id="2-游玩人员"><a href="#2-游玩人员" class="headerlink" title="(2).游玩人员"></a>(2).游玩人员</h3></li><li>大学老师 6人；</li><li>大学学生 30人（其中男生18人，女生12人）；</li><li>老人 ；</li><li>小学生；</li><li>幼儿园小朋友；<h2 id="4-出行方式"><a href="#4-出行方式" class="headerlink" title="4.出行方式"></a>4.出行方式</h2>由于出行人员中包括老人和儿童，所以轻轨等公共交通方式不适合他们乘坐，早8：00公共交通的人流量也非常大，到长春站的轻轨加上乘坐城际列车的费用是每人3 + 31.5 = 34.5元，回来时也是一样，所以如果乘坐轻轨+城际的总费用为：40 <em> 34.5 </em>2 = 2760元。租一辆47座配司机大巴车可以坐得下所有人，58同城上加的价格在1200左右， 两天就是接近2400元，大巴还可以带着大家出去玩，更加方便。所以综合出行便利程度和交通成本以及时间成本，选择47座大巴作为出行方式；<h2 id="5-景点规划"><a href="#5-景点规划" class="headerlink" title="5.景点规划"></a>5.景点规划</h2>文庙–松花湖风景名胜区–龙潭山–北山公园<h2 id="6-出行前的准备"><a href="#6-出行前的准备" class="headerlink" title="6.出行前的准备"></a>6.出行前的准备</h2></li><li>采购医疗包：医疗箱内需要有紧急处理晕车、跌打损伤、发烧等常见病症的药物，包尽量小；（付佳负责，10月10日12：00之前完成）</li><li>订大巴：联系大巴司机，商量好价钱、出发时间、住宿安排等，让司机提前查看我们出行的景点并规划路线；（张俊余负责，10月10日12：00之前完成）</li><li>订酒店：酒店定在北山公园旁边，需要含早餐，询问6位老师的携带家属情况安排住宿，同学们住标准间，包括谁和谁一个房间提前安排好；（王玉潘负责，10月8日12：00之前完成）</li><li>订饭店：集体吃的饭包括10月13日的晚饭和10月14日的午饭；（杨磊负责，10月12日12：00之前完成）</li><li>收钱：每个人收取300元；（公冶令鑫负责，10月8日12：00之前完成）</li><li>通知出发时间地点；（张俊余负责，10月6日12：00之前完成）</li><li>单反：条件允许的话借一个相机使用；（付佳负责，10月10日12：00之前将完成情况报给张俊余）<h2 id="7-出行"><a href="#7-出行" class="headerlink" title="7.出行"></a>7.出行</h2><h3 id="1-出发"><a href="#1-出发" class="headerlink" title="(1).出发"></a>(1).出发</h3>a.时间：10月13日8：00~10：00；<br>b.地点：东北师范大学净月校区雕塑门（北门）；<br>c.结果：经过2个小时到达吉林市北山公园附近宾馆；<br>d.内容：上车坐好后，30个人分为5组，每组6人，指定组长，组长负责出行期间组内人员的联系，总负责人在安排去下一个景点之前和组长沟通人是否齐全，车上时间由各组组长自行安排活动；<h3 id="2-宾馆修整"><a href="#2-宾馆修整" class="headerlink" title="(2).宾馆修整"></a>(2).宾馆修整</h3>a.时间：10月13日10：00~10：30；<br>b.地点：宾馆内；<br>c.内容：入住提前订好的宾馆，整理好个人物品后酒店门口集合；<h3 id="3-第一个景点——文庙"><a href="#3-第一个景点——文庙" class="headerlink" title="(3).第一个景点——文庙"></a>(3).第一个景点——文庙</h3>a.时间：10月13日10：40~11：40；<br>b.地点：文庙；<br>c.内容：步行前往文庙，吉林市文庙是中国的四大文庙之一,对民众免费开放，有科举展厅、免费讲解、还有吉林的人才简介，在这里大家可以感受吉林独有的文化特点；<h3 id="4-10月13日午饭及午休"><a href="#4-10月13日午饭及午休" class="headerlink" title="(4).10月13日午饭及午休"></a>(4).10月13日午饭及午休</h3>a.时间：10月13日12：00~14：00；<br>b.地点：文庙附近；<br>c.内容：考虑到有老人和儿童，给大家两个小时的时间自行在附近安排午饭及午休，14：00在酒店前台集合，组长做好组内人员的秩序维护工作；<h3 id="5-第二个景点——松花湖风景名胜区"><a href="#5-第二个景点——松花湖风景名胜区" class="headerlink" title="(5).第二个景点——松花湖风景名胜区"></a>(5).第二个景点——松花湖风景名胜区</h3>a.时间：10月13日14：10~17：30；<br>b.地点：酒店门口集合；<br>c.内容：乘坐大巴前往松花湖风景名胜区需要30分钟,松花湖景区门票10元，往返观光车车票10元，往返船票50元，共70元；进入景区后乘坐观光车10分钟即可到达码头，在码头上有著名的战船，乘坐战船在湖上行驶大约1个小时到达五虎岛，坐船游览是松花湖的特色项目，想要拍照的话是个绝佳的地方；到达五虎岛后，不去儿童乐园，去看丰满水电站大坝，整个过程一定注意人身安全；<h3 id="6-10月13日晚饭"><a href="#6-10月13日晚饭" class="headerlink" title="(6).10月13日晚饭"></a>(6).10月13日晚饭</h3>a.时间：10月13日17：40~19：20；<br>b.地点：宾馆附近之前已经提前订好并且点号特色菜的饭店；<br>c.内容：品尝吉林市的特色美食；<h3 id="7-10月13日晚休"><a href="#7-10月13日晚休" class="headerlink" title="(7).10月13日晚休"></a>(7).10月13日晚休</h3>a.时间：10月13日19：20；<br>b.地点：宾馆及其他；<br>c.内容：晚饭后大家自由安排时间，可以出去玩或者宾馆里老师同学们一起玩；<h3 id="8-10月14日早饭"><a href="#8-10月14日早饭" class="headerlink" title="(8).10月14日早饭"></a>(8).10月14日早饭</h3>a.时间：10月14日7：00~8：00；<br>b.地点：宾馆；<br>c.内容：组长叫组内成员起床吃早饭，因为之前定的宾馆是含早餐的，所以早餐在宾馆内解决，吃完后大家在宾馆前台集合，提前通知收拾东西退房；<h3 id="9-第三个景点——龙潭山遗址公园"><a href="#9-第三个景点——龙潭山遗址公园" class="headerlink" title="(9).第三个景点——龙潭山遗址公园"></a>(9).第三个景点——龙潭山遗址公园</h3>a.时间：10月14日8：20~11：30；<br>b.地点：龙潭山遗址公园；<br>c.内容：早饭后集合完毕步行前往龙潭山遗址公园，公园内环境非常好，适合集体活动和进行各种集体游戏，带好防潮垫等装备让老人和儿童能够休息和方便午饭；<h3 id="10-10月14日午饭及午休"><a href="#10-10月14日午饭及午休" class="headerlink" title="(10).10月14日午饭及午休"></a>(10).10月14日午饭及午休</h3>a.时间：10月14日11：40~13：30；<br>b.地点：龙潭山遗址公园；<br>c.内容：在龙潭山活动后，午饭同样是自行安排，也可以自带午饭就在公园内吃，但是注意环境卫生，约定一个地点在13：30集合；<h3 id="11-第四个景点——北山公园"><a href="#11-第四个景点——北山公园" class="headerlink" title="(11).第四个景点——北山公园"></a>(11).第四个景点——北山公园</h3>a.时间：10月14日13：40~15：20；<br>b.地点：北山公园；<br>c.内容：中午午饭及午休完成后不行前往北山公园，公园里有假山、喷泉、园林等自然景观可供拍照留念，情侣园有同心锁、红绳、烧香等项目，还有玉皇阁、揽月亭等古建筑,接下来去看冬奥会采集圣火的地方；<h3 id="10-回学校"><a href="#10-回学校" class="headerlink" title="(10).回学校"></a>(10).回学校</h3>a.时间：10月14日15：30~17：30；<br>b.地点：北山公园门口大巴车；<br>c.内容：坐大巴回学校，路上大家可以交流拍的照片等诸多活动，同样由各组组长自行安排；<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2>制作整个出行过程的公共消费账单；（张俊余负责，10月14日23：00之前发给老师和班级群）<br>收集同学们的照片建立网盘并分享给老师和同学们；（张俊余负责，10月18日12：00前将连接发给老师和班级群）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本作业的要求：[&lt;a href=&quot;https://edu.cnblogs.com/campus/nenu/2018fall/homework/2149]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://edu.cnblogs.com/camp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何更改Git提交的远程仓库</title>
    <link href="http://blog.ijunyu.top/2018/10/03/HowToChangeGitReposity/"/>
    <id>http://blog.ijunyu.top/2018/10/03/HowToChangeGitReposity/</id>
    <published>2018-10-03T07:13:32.000Z</published>
    <updated>2018-10-03T08:10:00.078Z</updated>
    
    <content type="html"><![CDATA[<p>近期的高级软件工程作业中有个要求是新建一个Git仓库提交修改其他人bug的代码，我们最开始是默认是把本地项目提交到自己的项目Git地址上，现在需要做的是更改远程仓库的地址，使我们更改过的别人的代码提交到新的仓库，下面是具体步骤。</p><h1 id="1-在本地建立和项目名称相同的文件夹"><a href="#1-在本地建立和项目名称相同的文件夹" class="headerlink" title="1.在本地建立和项目名称相同的文件夹"></a>1.在本地建立和项目名称相同的文件夹</h1><p>新建文件夹的名称必须和Git中的项目名称完全相同，否则无法将本地内容推送到远程仓库，这一点切记。本例中我在本地新建一个名为modify_yuyang_bugs的文件夹，在Git客户端中以下代码建立项目文件夹：<br><code>mkdir modify_yuyang_bugs</code><br>然后进入新建的文件夹：<br><code>cd modify_yuyang_bugs</code><br>然后在文件夹内将本地的文件夹和远程仓库建立Git连接：<br><code>git init</code></p><h1 id="2-建立远程仓库"><a href="#2-建立远程仓库" class="headerlink" title="2.建立远程仓库"></a>2.建立远程仓库</h1><p>在coding.net中建立新的远程项目仓库，名称一定要和第1步中建立的文件夹的名称相同，本例中建立的仓库名称为：<code>modify_yuyang_bugs</code> </p><h1 id="3-远程仓库和本地仓库的连接"><a href="#3-远程仓库和本地仓库的连接" class="headerlink" title="3.远程仓库和本地仓库的连接"></a>3.远程仓库和本地仓库的连接</h1><p>在Git客户端中输入：<br><code>git remote add origin https://git.coding.net/zhangjy982/modify_yuyang_bugs.git</code><br>命令，其中origin是我自己为远程仓库起的名字，可以根据自己的需要和习惯起名字，后面的链接是我新建的Git远程项目的地址，需要根据自己的具体项目地址进行相应的更改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期的高级软件工程作业中有个要求是新建一个Git仓库提交修改其他人bug的代码，我们最开始是默认是把本地项目提交到自己的项目Git地址上，现在需要做的是更改远程仓库的地址，使我们更改过的别人的代码提交到新的仓库，下面是具体步骤。&lt;/p&gt;
&lt;h1 id=&quot;1-在本地建立和项目
      
    
    </summary>
    
    
      <category term="Git" scheme="http://blog.ijunyu.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>作业要求20170925-2 功能测试</title>
    <link href="http://blog.ijunyu.top/2018/09/27/BugCount/"/>
    <id>http://blog.ijunyu.top/2018/09/27/BugCount/</id>
    <published>2018-09-27T06:26:05.000Z</published>
    <updated>2018-10-04T08:56:00.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、bug计分"><a href="#一、bug计分" class="headerlink" title="一、bug计分"></a>一、bug计分</h1><h2 id="1-第一个bug"><a href="#1-第一个bug" class="headerlink" title="1.第一个bug"></a>1.第一个bug</h2><h3 id="1-标题：于洋功能1输出格式错误，多加了words"><a href="#1-标题：于洋功能1输出格式错误，多加了words" class="headerlink" title="(1).标题：于洋功能1输出格式错误，多加了words"></a>(1).标题：于洋功能1输出格式错误，多加了words</h3><h3 id="2-bug内容："><a href="#2-bug内容：" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境"><a href="#a-测试环境" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作"><a href="#b-准备工作" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将于洋同学的wf.py文件转换为Windows可执行文件;</p><h4 id="c-测试步骤"><a href="#c-测试步骤" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>进入生成的wf.exe文件所在文件夹;<br>输入 <code>wf -s test.txt</code>  </p><h4 id="d-运行结果"><a href="#d-运行结果" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>插入yufunction1图片</p><h4 id="e-期待运行结果"><a href="#e-期待运行结果" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>插入myfunction1</p><h4 id="f-运行结果与期待运行结果的差异"><a href="#f-运行结果与期待运行结果的差异" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>运行结果比期待运行结果的”total”后面多出现了一个单词”words”</p><h3 id="3-佐证材料"><a href="#3-佐证材料" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图"><a href="#a-运行截图" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入yufunction1图片</p><h4 id="b-作业spec"><a href="#b-作业spec" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h2 id="2-第二个bug"><a href="#2-第二个bug" class="headerlink" title="2.第二个bug"></a>2.第二个bug</h2><h3 id="1-标题：于洋功能二只输出词频排名前10的单词"><a href="#1-标题：于洋功能二只输出词频排名前10的单词" class="headerlink" title="(1).标题：于洋功能二只输出词频排名前10的单词"></a>(1).标题：于洋功能二只输出词频排名前10的单词</h3><h3 id="2-bug内容：-1"><a href="#2-bug内容：-1" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-1"><a href="#a-测试环境-1" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作-1"><a href="#b-准备工作-1" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将于洋同学的wf.py文件转换为Windows可执行文件;</p><h4 id="c-测试步骤-1"><a href="#c-测试步骤-1" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>进入生成的wf.exe文件所在文件夹;<br>输入 <code>wf war_and_peace.txt</code>  </p><h4 id="d-运行结果-1"><a href="#d-运行结果-1" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>输出了total和词频排名前10的单词及对应词频</p><h4 id="e-期待运行结果-1"><a href="#e-期待运行结果-1" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>输出total值和所有不重复单词及对应词频</p><h4 id="f-运行结果与期待运行结果的差异-1"><a href="#f-运行结果与期待运行结果的差异-1" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>运行结果比期待运行结果少了词频排名不在前10中的数据</p><h3 id="3-佐证材料-1"><a href="#3-佐证材料-1" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-1"><a href="#a-运行截图-1" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入yufunction2图片</p><h4 id="b-作业spec-1"><a href="#b-作业spec-1" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h2 id="3-第三个bug"><a href="#3-第三个bug" class="headerlink" title="3.第三个bug"></a>3.第三个bug</h2><h3 id="1-标题：孙韦男命令行运行程序弹出：”please-input-the-name-of-book”"><a href="#1-标题：孙韦男命令行运行程序弹出：”please-input-the-name-of-book”" class="headerlink" title="(1).标题：孙韦男命令行运行程序弹出：”please input the name of book”"></a>(1).标题：孙韦男命令行运行程序弹出：”please input the name of book”</h3><h3 id="2-bug内容：-2"><a href="#2-bug内容：-2" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-2"><a href="#a-测试环境-2" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>bash shell;</p><h4 id="b-准备工作-2"><a href="#b-准备工作-2" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将孙韦男同学的项目下载;</p><h4 id="c-测试步骤-2"><a href="#c-测试步骤-2" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>使用git bash打开项目的main.sh文件;    </p><h4 id="d-运行结果-2"><a href="#d-运行结果-2" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>在bash shell中直接弹出提示消息：”please input the name of book”</p><h4 id="e-期待运行结果-2"><a href="#e-期待运行结果-2" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>命令行直接输入参数运行程序；</p><h4 id="f-运行结果与期待运行结果的差异-2"><a href="#f-运行结果与期待运行结果的差异-2" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>虽然看起来是命令行，但是实际上还是控制台操作；</p><h3 id="3-佐证材料-2"><a href="#3-佐证材料-2" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-2"><a href="#a-运行截图-2" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入swnbug1图片</p><h4 id="b-作业spec-2"><a href="#b-作业spec-2" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h2 id="4-第四个bug"><a href="#4-第四个bug" class="headerlink" title="4.第四个bug"></a>4.第四个bug</h2><h3 id="1-标题：孙韦男功能1单词输出未排序"><a href="#1-标题：孙韦男功能1单词输出未排序" class="headerlink" title="(1).标题：孙韦男功能1单词输出未排序"></a>(1).标题：孙韦男功能1单词输出未排序</h3><h3 id="2-bug内容：-3"><a href="#2-bug内容：-3" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-3"><a href="#a-测试环境-3" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作-3"><a href="#b-准备工作-3" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将孙韦男同学的项目下载;</p><h4 id="c-测试步骤-3"><a href="#c-测试步骤-3" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>将py文件转化为Windows可执行文件(.exe);<br>输入 <code>wf -s test.txt</code>   </p><h4 id="d-运行结果-3"><a href="#d-运行结果-3" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>单词未经过词频从高到低排序就执行了输出；</p><h4 id="e-期待运行结果-3"><a href="#e-期待运行结果-3" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>单词按照词频排序后输出；</p><h4 id="f-运行结果与期待运行结果的差异-3"><a href="#f-运行结果与期待运行结果的差异-3" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>单词及词频输出未排序；</p><h3 id="3-佐证材料-3"><a href="#3-佐证材料-3" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-3"><a href="#a-运行截图-3" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入swnrepairbug1图片</p><h4 id="b-作业spec-3"><a href="#b-作业spec-3" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h2 id="5-第五个bug"><a href="#5-第五个bug" class="headerlink" title="5.第五个bug"></a>5.第五个bug</h2><h3 id="1-标题：孙韦男功能1的total位置和格式不对"><a href="#1-标题：孙韦男功能1的total位置和格式不对" class="headerlink" title="(1).标题：孙韦男功能1的total位置和格式不对"></a>(1).标题：孙韦男功能1的total位置和格式不对</h3><h3 id="2-bug内容：-4"><a href="#2-bug内容：-4" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-4"><a href="#a-测试环境-4" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作-4"><a href="#b-准备工作-4" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将孙韦男同学的项目下载;</p><h4 id="c-测试步骤-4"><a href="#c-测试步骤-4" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>将py文件转化为Windows可执行文件(.exe);<br>输入 <code>wf -s test.txt</code>  </p><h4 id="d-运行结果-4"><a href="#d-运行结果-4" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>total出现在单词及其词频之后；</p><h4 id="e-期待运行结果-4"><a href="#e-期待运行结果-4" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>先输出total值再输出单词及其词频；</p><h4 id="f-运行结果与期待运行结果的差异-4"><a href="#f-运行结果与期待运行结果的差异-4" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>输出格式存在错误；</p><h3 id="3-佐证材料-4"><a href="#3-佐证材料-4" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-4"><a href="#a-运行截图-4" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入swnbug2图片</p><h4 id="b-作业spec-4"><a href="#b-作业spec-4" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h1 id="二、自己的bug报告"><a href="#二、自己的bug报告" class="headerlink" title="二、自己的bug报告"></a>二、自己的bug报告</h1><h2 id="1-第一个bug-1"><a href="#1-第一个bug-1" class="headerlink" title="1.第一个bug"></a>1.第一个bug</h2><h3 id="1-标题：功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容"><a href="#1-标题：功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容" class="headerlink" title="(1).标题：功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容"></a>(1).标题：功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容</h3><h3 id="2-bug内容：-5"><a href="#2-bug内容：-5" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-5"><a href="#a-测试环境-5" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作-5"><a href="#b-准备工作-5" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将自己的wf.py文件转换为Windows可执行文件;</p><h4 id="c-测试步骤-5"><a href="#c-测试步骤-5" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>进入生成的wf.exe文件所在文件夹;<br>输入 <code>wf -s war_and_peace.txt</code>  </p><h4 id="d-运行结果-5"><a href="#d-运行结果-5" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>执行后若文件多行之间使用换行符换行则只能读取文件第一行的内容</p><h4 id="e-期待运行结果-5"><a href="#e-期待运行结果-5" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>重定向之后的输出应该和功能二相同；</p><h4 id="f-运行结果与期待运行结果的差异-5"><a href="#f-运行结果与期待运行结果的差异-5" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>只读取了文件内容第一个换行符之前的内容；</p><h3 id="3-佐证材料-5"><a href="#3-佐证材料-5" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-5"><a href="#a-运行截图-5" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入mybug1图片</p><h4 id="b-作业spec-5"><a href="#b-作业spec-5" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入spec4</p><h2 id="2-第二个bug-1"><a href="#2-第二个bug-1" class="headerlink" title="2.第二个bug"></a>2.第二个bug</h2><h3 id="1-标题：对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码"><a href="#1-标题：对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码" class="headerlink" title="(1).标题：对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码"></a>(1).标题：对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码</h3><h3 id="2-bug内容：-6"><a href="#2-bug内容：-6" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-6"><a href="#a-测试环境-6" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作-6"><a href="#b-准备工作-6" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将自己的wf.py文件转换为Windows可执行文件;</p><h4 id="c-测试步骤-6"><a href="#c-测试步骤-6" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>进入生成的wf.exe文件所在文件夹;<br>输入 <code>wf b.txt</code>  </p><h4 id="d-运行结果-6"><a href="#d-运行结果-6" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>在词频统计的单词显示中，带有”—“符号的单词出现了乱码。</p><h4 id="e-期待运行结果-6"><a href="#e-期待运行结果-6" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>正确显示单词的完整内容</p><h4 id="f-运行结果与期待运行结果的差异-6"><a href="#f-运行结果与期待运行结果的差异-6" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>出现乱码</p><h3 id="3-佐证材料-6"><a href="#3-佐证材料-6" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-6"><a href="#a-运行截图-6" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入mybug2图片</p><h4 id="b-作业spec-6"><a href="#b-作业spec-6" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h2 id="3-第三个bug-1"><a href="#3-第三个bug-1" class="headerlink" title="3.第三个bug"></a>3.第三个bug</h2><h3 id="1-标题：输出单词及词频的时候多加了空行，功能2total缺少了words"><a href="#1-标题：输出单词及词频的时候多加了空行，功能2total缺少了words" class="headerlink" title="(1).标题：输出单词及词频的时候多加了空行，功能2total缺少了words"></a>(1).标题：输出单词及词频的时候多加了空行，功能2total缺少了words</h3><h3 id="2-bug内容：-7"><a href="#2-bug内容：-7" class="headerlink" title="(2).bug内容："></a>(2).bug内容：</h3><h4 id="a-测试环境-7"><a href="#a-测试环境-7" class="headerlink" title="a.测试环境"></a>a.测试环境</h4><p>Windows Professional 64bit;<br>cmd;</p><h4 id="b-准备工作-7"><a href="#b-准备工作-7" class="headerlink" title="b.准备工作"></a>b.准备工作</h4><p>将自己的wf.py文件转换为Windows可执行文件;</p><h4 id="c-测试步骤-7"><a href="#c-测试步骤-7" class="headerlink" title="c.测试步骤"></a>c.测试步骤</h4><p>进入生成的wf.exe文件所在文件夹;<br>输入 <code>wf test.txt</code>  </p><h4 id="d-运行结果-7"><a href="#d-运行结果-7" class="headerlink" title="d.运行结果"></a>d.运行结果</h4><p>单词之间有多余的空行，total后面只有统计的数据</p><h4 id="e-期待运行结果-7"><a href="#e-期待运行结果-7" class="headerlink" title="e.期待运行结果"></a>e.期待运行结果</h4><p>单词之间没有空行，total后面有统计的数据和单词”words”</p><h4 id="f-运行结果与期待运行结果的差异-7"><a href="#f-运行结果与期待运行结果的差异-7" class="headerlink" title="f.运行结果与期待运行结果的差异"></a>f.运行结果与期待运行结果的差异</h4><p>多了空行少了”words”</p><h3 id="3-佐证材料-7"><a href="#3-佐证材料-7" class="headerlink" title="(3).佐证材料"></a>(3).佐证材料</h3><h4 id="a-运行截图-7"><a href="#a-运行截图-7" class="headerlink" title="a.运行截图"></a>a.运行截图</h4><p>插入mybug3图片</p><h4 id="b-作业spec-7"><a href="#b-作业spec-7" class="headerlink" title="b.作业spec"></a>b.作业spec</h4><p>插入function1spec</p><h1 id="三、修改bug"><a href="#三、修改bug" class="headerlink" title="三、修改bug"></a>三、修改bug</h1><h2 id="1-修改”于洋功能1输出格式错误，多加了words”这一bug"><a href="#1-修改”于洋功能1输出格式错误，多加了words”这一bug" class="headerlink" title="1.修改”于洋功能1输出格式错误，多加了words”这一bug"></a>1.修改”于洋功能1输出格式错误，多加了words”这一bug</h2><h3 id="1-修改后git地址："><a href="#1-修改后git地址：" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/modify_yuyang_bugs.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/modify_yuyang_bugs.git</a>  </p><h3 id="2-修改后输出截图："><a href="#2-修改后输出截图：" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>yuyangdebug1</p><h3 id="3-测试报告："><a href="#3-测试报告：" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt测试通过；<br>未发现测试用例之外的bug；  </p><h2 id="2-修改”于洋功能二只输出词频排名前10的单词”这一bug"><a href="#2-修改”于洋功能二只输出词频排名前10的单词”这一bug" class="headerlink" title="2.修改”于洋功能二只输出词频排名前10的单词”这一bug"></a>2.修改”于洋功能二只输出词频排名前10的单词”这一bug</h2><h3 id="1-修改后git地址：-1"><a href="#1-修改后git地址：-1" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/modify_yuyang_bugs.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/modify_yuyang_bugs.git</a>  </p><h3 id="2-修改后输出截图：-1"><a href="#2-修改后输出截图：-1" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>yuyangdebug2</p><h3 id="3-测试报告：-1"><a href="#3-测试报告：-1" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>未发现测试用例之外的bug；</p><h2 id="3-修改”孙韦男命令行运行程序弹出：”please-input-the-name-of-book””这一bug"><a href="#3-修改”孙韦男命令行运行程序弹出：”please-input-the-name-of-book””这一bug" class="headerlink" title="3.修改”孙韦男命令行运行程序弹出：”please input the name of book””这一bug"></a>3.修改”孙韦男命令行运行程序弹出：”please input the name of book””这一bug</h2><h3 id="1-修改后git地址：-2"><a href="#1-修改后git地址：-2" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/modify_swn_bugs.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/modify_swn_bugs.git</a>  </p><h3 id="2-修改后输出截图：-2"><a href="#2-修改后输出截图：-2" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>swnrepairbug1</p><h3 id="3-测试报告：-2"><a href="#3-测试报告：-2" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>将py文件转化为可执行文件；<br>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>测试完成后发现新bug：<br>a.单词输出未排序；<br>b.total输出位置错误； </p><h2 id="4-修改”孙韦男功能1单词输出未排序”这一bug"><a href="#4-修改”孙韦男功能1单词输出未排序”这一bug" class="headerlink" title="4.修改”孙韦男功能1单词输出未排序”这一bug"></a>4.修改”孙韦男功能1单词输出未排序”这一bug</h2><h3 id="1-修改后git地址：-3"><a href="#1-修改后git地址：-3" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/modify_swn_bugs.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/modify_swn_bugs.git</a>  </p><h3 id="2-修改后输出截图：-3"><a href="#2-修改后输出截图：-3" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>swnbug2</p><h3 id="3-测试报告：-3"><a href="#3-测试报告：-3" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>测试完成后未发现新bug；</p><h2 id="5-修改”孙韦男功能1的total位置和格式不对”这一bug"><a href="#5-修改”孙韦男功能1的total位置和格式不对”这一bug" class="headerlink" title="5.修改”孙韦男功能1的total位置和格式不对”这一bug"></a>5.修改”孙韦男功能1的total位置和格式不对”这一bug</h2><h3 id="1-修改后git地址：-4"><a href="#1-修改后git地址：-4" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/modify_swn_bugs.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/modify_swn_bugs.git</a>  </p><h3 id="2-修改后输出截图：-4"><a href="#2-修改后输出截图：-4" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>swnrepairbug2</p><h3 id="3-测试报告：-4"><a href="#3-测试报告：-4" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>测试完成后未发现新bug；</p><h2 id="6-修改”自己功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容”这一bug"><a href="#6-修改”自己功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容”这一bug" class="headerlink" title="6.修改”自己功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容”这一bug"></a>6.修改”自己功能4重定向对输入文本中的换行符执行了文件输入停止操作导致无法读取文件全部内容”这一bug</h2><h3 id="1-修改后git地址：-5"><a href="#1-修改后git地址：-5" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/word_count.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/word_count.git</a>  </p><h3 id="2-修改后输出截图：-5"><a href="#2-修改后输出截图：-5" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>mybugrepair1</p><h3 id="3-测试报告：-5"><a href="#3-测试报告：-5" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>测试完成后未发现新bug;</p><h2 id="7-修改”自己对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码”这一bug"><a href="#7-修改”自己对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码”这一bug" class="headerlink" title="7.修改”自己对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码”这一bug"></a>7.修改”自己对于标点符号的处理仍有不完善，比如中文破折号的一半”—“在处理中出现了乱码”这一bug</h2><h3 id="1-修改后git地址：-6"><a href="#1-修改后git地址：-6" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/word_count.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/word_count.git</a>  </p><h3 id="2-修改后输出截图：-6"><a href="#2-修改后输出截图：-6" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>mybugrepair2</p><h3 id="3-测试报告：-6"><a href="#3-测试报告：-6" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>测试完成后未发现新bug;  </p><h2 id="8-修改”自己输出单词及词频的时候多加了空行，功能2的total缺少了words”这一bug"><a href="#8-修改”自己输出单词及词频的时候多加了空行，功能2的total缺少了words”这一bug" class="headerlink" title="8.修改”自己输出单词及词频的时候多加了空行，功能2的total缺少了words”这一bug"></a>8.修改”自己输出单词及词频的时候多加了空行，功能2的total缺少了words”这一bug</h2><h3 id="1-修改后git地址：-7"><a href="#1-修改后git地址：-7" class="headerlink" title="(1).修改后git地址："></a>(1).修改后git地址：</h3><p><a href="https://git.coding.net/zhangjy982/word_count.git" target="_blank" rel="noopener">https://git.coding.net/zhangjy982/word_count.git</a>  </p><h3 id="2-修改后输出截图：-7"><a href="#2-修改后输出截图：-7" class="headerlink" title="(2).修改后输出截图："></a>(2).修改后输出截图：</h3><p>mybugrepair3</p><h3 id="3-测试报告：-7"><a href="#3-测试报告：-7" class="headerlink" title="(3).测试报告："></a>(3).测试报告：</h3><p>test.txt、war_and_peace.txt、the_dead_return.txt均测试通过；<br>测试完成后未发现新bug;  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、bug计分&quot;&gt;&lt;a href=&quot;#一、bug计分&quot; class=&quot;headerlink&quot; title=&quot;一、bug计分&quot;&gt;&lt;/a&gt;一、bug计分&lt;/h1&gt;&lt;h2 id=&quot;1-第一个bug&quot;&gt;&lt;a href=&quot;#1-第一个bug&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="SoftwareEngineering" scheme="http://blog.ijunyu.top/tags/SoftwareEngineering/"/>
    
  </entry>
  
  <entry>
    <title>词频统计</title>
    <link href="http://blog.ijunyu.top/2018/09/24/WordsFreq/"/>
    <id>http://blog.ijunyu.top/2018/09/24/WordsFreq/</id>
    <published>2018-09-23T16:06:53.000Z</published>
    <updated>2018-10-05T08:29:55.876Z</updated>
    
    <content type="html"><![CDATA[<p>此作业要求参见  <a href="https://edu.cnblogs.com/campus/nenu/2018fall/homework/2126" target="_blank" rel="noopener">https://edu.cnblogs.com/campus/nenu/2018fall/homework/2126</a></p><h1 id="一、项目功能的重点和难点"><a href="#一、项目功能的重点和难点" class="headerlink" title="一、项目功能的重点和难点"></a>一、项目功能的重点和难点</h1><h2 id="1-功能一中的重点和难点"><a href="#1-功能一中的重点和难点" class="headerlink" title="1.功能一中的重点和难点"></a>1.功能一中的重点和难点</h2><h3 id="1-文件读取"><a href="#1-文件读取" class="headerlink" title="(1).文件读取"></a>(1).文件读取</h3><p>&emsp;&emsp;功能要求从文件中读取数据信息，那么首先要处理的就是数据读入问题，项目采用Python语言编码（以下如果无特殊说明，所用方法均基于Python），Python对于文件读入有非常实用的方法：open(filename,mode,buffering,encoding)方法，其中filename为文件全称，mode为文件的读取模式，buffering为j寄存区的缓冲大小，encoding为文件的编码方式，代码如下：<br><code>f = open(str,&#39;r&#39;,-1,&#39;utf-8&#39;)  #str为待输入文件名，&#39;r&#39;代表只读模式,&#39;-1&#39;为默认缓冲区大小</code></p><h3 id="2-分词依据"><a href="#2-分词依据" class="headerlink" title="(2).分词依据"></a>(2).分词依据</h3><p>&emsp;&emsp;统计词频，首先要做的就是区分什么是一个单词。第一，单词是不包括标点符号的；第二，本作业的要求是word中对单词的定义，根据个人的观察和试验，得出结论，word中的分词依据主要是空格、英文破折号（—）、和双短横线（–）。根据这两点分析，对于分词功能，主要采取的方法是首先将所有字符小写，用到的是Python中字符串的lower()方法，然后将文档中的标点符号和换行符使用空格进行替换，替换之后每个单词之间都是由空格相隔开，然后使用字符串处理的split()方法将所有的单词保存于列表（list）中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tet = f.read().lower()</span><br><span class="line">text = tet.replace(&apos;\n&apos;,&apos; &apos;).replace(&apos;.&apos;,&apos; &apos;).replace(&apos;,&apos;,&apos; &apos;).\</span><br><span class="line">        replace(&apos;!&apos;,&apos; &apos;).replace(&apos;\\&apos;,&apos; &apos;).replace(&apos;#&apos;,&apos; &apos;).\</span><br><span class="line">        replace(&apos;[&apos;,&apos; &apos;).replace(&apos;]&apos;,&apos; &apos;).replace(&apos;:&apos;,&apos; &apos;).\</span><br><span class="line">        replace(&apos;?&apos;,&apos; &apos;).replace(&apos;-&apos;,&apos; &apos;).replace(&apos;\&apos;&apos;,&apos; &apos;).\</span><br><span class="line">        replace(&apos;\&quot;&apos;,&apos; &apos;).replace(&apos;(&apos;,&apos; &apos;).replace(&apos;)&apos;,&apos; &apos;).\</span><br><span class="line">        replace(&apos;—&apos;,&apos; &apos;).replace(&apos;;&apos;,&apos; &apos;).split()</span><br></pre></td></tr></table></figure></p><h3 id="3-命令行参数"><a href="#3-命令行参数" class="headerlink" title="(3).命令行参数"></a>(3).命令行参数</h3><p>&emsp;&emsp;作业要求在控制台输入命令并执行，而Python脚本文件无法直接在命令行执行，这里我的做法是将Python脚本(.py)转换为可执行文件(.exe)，这样就可以实现命令行输入并执行相应操作，具体的实现过程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此作业要求参见  &lt;a href=&quot;https://edu.cnblogs.com/campus/nenu/2018fall/homework/2126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://edu.cnblogs.com/camp
      
    
    </summary>
    
    
      <category term="SoftwareEngineering" scheme="http://blog.ijunyu.top/tags/SoftwareEngineering/"/>
    
  </entry>
  
  <entry>
    <title>Python脚本文件(.py)打包为可执行文件(.exe)</title>
    <link href="http://blog.ijunyu.top/2018/09/20/py2exe/"/>
    <id>http://blog.ijunyu.top/2018/09/20/py2exe/</id>
    <published>2018-09-20T05:14:41.000Z</published>
    <updated>2018-09-20T06:48:07.397Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在最近的软件工程作业中用到了将Python脚本转化为exe文件这一过程，网上各种博客介绍了很多，有些东西都不完全，我也是综合了很多种方法最后才实现的，我就把这些整理出来，希望可以帮到大家~  </p><h1 id="一、环境和工具"><a href="#一、环境和工具" class="headerlink" title="一、环境和工具"></a>一、环境和工具</h1><p>-Windows 10 Enterprise 64bit<br>-Python 3.6.4<br>-pyinstaller<br>-pip 18.0    </p><h1 id="二、实现过程"><a href="#二、实现过程" class="headerlink" title="二、实现过程"></a>二、实现过程</h1><h2 id="1-pip安装pyinstaller"><a href="#1-pip安装pyinstaller" class="headerlink" title="1. pip安装pyinstaller"></a>1. pip安装pyinstaller</h2><h3 id="1-Python和pip的使用"><a href="#1-Python和pip的使用" class="headerlink" title="(1).Python和pip的使用"></a>(1).Python和pip的使用</h3><p>pip类似于linux中的yumy，但它是依赖于Python的，如果你已经成功安装Python相关版本并且配置好环境变量，就可以使用pip进行软件安装。在cmd下输入<code>python</code>如果出现对应的版本等信息，说明是安装成功的；同样，cmd下输入<code>pip</code>如果弹出来很多帮助信息也说明pip是可用的；更多安装相关内容可以百度，这里不赘述。</p><h3 id="2-安装pyinstaller"><a href="#2-安装pyinstaller" class="headerlink" title="(2).安装pyinstaller"></a>(2).安装pyinstaller</h3><p>&emsp;&emsp;首先，进入Python安装目录的Scripts文件夹下，如果你忘记了Python的安装位置，可以通过命令行的方式显示安装路径。具体操作为：cmd下输入python进入Python编辑器环境，然后输入代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path</span><br></pre></td></tr></table></figure></p><p>我的Python安装路径是：C:\Users\zhang\AppData\Programs\Python\Python36文件夹下，那么我的安装路径查看效果如下图所示：<br><img src="https://i.imgur.com/IJvOGkN.png" alt=""><br>输入<code>cd C:\Users\zhang\AppData\Local\Programs\Python\Python36\Scripts\</code><br>进入Python的Scripts文件夹。<br>&emsp;&emsp;然后，在cmd中输入命令：<code>pip.exe install Pyinstaller</code>，<br>接下来会完成pyinstaller的安装,安装完成后在Scripts文件夹中会出现pyinstaller.exe，说明安装成功。</p><h2 id="2-py2exe"><a href="#2-py2exe" class="headerlink" title="2. py2exe"></a>2. py2exe</h2><p>&emsp;&emsp;最后，通过命令行的方式实现Python脚本到exe的转换，命令格式为：<br><code>pyinstaller.exe [-parameter] filename</code>，其中[-parameter]共有三个参数，<code>-w</code>参数k可以屏蔽m命令行调试窗口；<code>-F</code>参数可以把脚本打包成一个独立的exe文件,否则是一个带各种dll和依赖文件的文件夹；<code>-p</code>参数可以增加pyinstaller搜索模块的路径，这里我们使用<code>-F</code>参数就可以满足需要。filename参数是要打包的脚本文件的完全路径，比如我的脚本文件wf.py放在<code>C:\Users\zhang\source\repos\wc\wc</code>文件夹下，那我我的filename的值就是：<code>C:\Users\zhang\source\repos\wc\wc\wf.py</code><br>&emsp;&emsp;所以，我要输入的命令就是：<code>pyinstaller.exe -F C:\Users\zhang\source\repos\wc\wc\wf.py</code><br>&emsp;&emsp;执行完毕后在Scripts文件下会生成一个dist文件夹，dist文件夹就存放着刚生成的wf.exe文件，至此，py2exe的整个过程就结束了，我们也实现了目标。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在最近的软件工程作业中用到了将Python脚本转化为exe文件这一过程，网上各种博客介绍了很多，有些东西都不完全，我也是综合了很多种方法最后才实现的，我就把这些整理出来，希望可以帮到大家~  &lt;/p&gt;
&lt;h1 id=&quot;一、环境和工具&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://blog.ijunyu.top/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Thinking</title>
    <link href="http://blog.ijunyu.top/2018/09/17/Thinking/"/>
    <id>http://blog.ijunyu.top/2018/09/17/Thinking/</id>
    <published>2018-09-16T18:35:51.000Z</published>
    <updated>2018-09-20T06:22:55.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-回想曾经对计算机专业的畅想"><a href="#1-回想曾经对计算机专业的畅想" class="headerlink" title="1.回想曾经对计算机专业的畅想"></a>1.回想曾经对计算机专业的畅想</h2><p>&emsp;&emsp;选择计算机专业其实也是比较偶然吧，因为是被调剂到软件工程专业的。当时高考成绩不太理想，距离理想的学校差距很大，当时正好山东开始有了平行志愿，前几个都报的有点高了，家里那时候挺想让我当老师的，就让我填个师范学校，其实当时也是为了敷衍一下他们就填了东北师大，也没想到前三个都没过，就被东北师大录了，师范专业分还不够，然后就被调剂到了软件工程。其实之前对计算机专业了解的真的很少，基本上仅限于高中学的很少的Basic语言。<br>&emsp;&emsp;之前有段时间特别喜欢刷知乎，所以对轮子哥还是非常欣赏甚至崇拜的（逃，一开始对于计算机的期待大概就是做一个像轮子哥一样的程序员大佬，按他的说法就是没那个难就进了微软，根据自己的兴趣爱好做项目，做编译器，老师推荐的博客里轮子哥的那篇博客之前也在朋友圈里被好多人转发过，我想应该很多人最开始对程序员的一种向往就是轮子哥那种吧。学院的课程是否和期待的一样，我感觉在我心里还是有一个变化的过程的，开始觉得数据结构、C语言、操作系统等课程以后在工程上用的很少，甚至在网站开发上有些东西根本用不到，离自己期待的还有些远，后来才慢慢发现工程代码也不是纯粹的写各种代码，还是要有思想在里面的，后来大三的时候也面试过好多公司，那时候是真的切实的意识到基础课的重要性，我还很清楚的记得第一次面试的时候面试官问了一个关于进程的问题我就只有印象却什么说不出来的窘境，所以那次面试也非常的惨，我估计面试官也还绝望吧。现在回想一下，特别是在看完几个大佬的博客之后，觉得对于现在的我来说，学院的课程基本上应该是符合期待的，这些都是在以后能用得上的，但是遗憾的是当时没有意识到这个问题，所以现在应该再去回顾一下这些基础课，亡羊补牢，为时未晚，共勉吧!<br>&emsp;&emsp;对于现在的我来说，计算机当时是我喜欢的领域，我觉得计算机现在是最能改变人们生活方式的一个行业，本科时候潘老师经常跟我们说，做项目的想法有很多，随时观察身边的事物就不愁项目没有想法，如果觉得生活中有什么事或者什么方式你觉得不方便，就可以去想是不是可以通过编程的方式去解决，如果可以，就进一步去挖掘这个想法的潜在价值，这样一个项目就可以进行下去了。之后做的国创或者科研立项等等都是在生活的基础上进行的，做过店铺排队的系统，也做过商场的服务APP，我觉得这些都是做出来能对周围人的生活产生积极的影响的，我觉得这个行业很有价值，这个价值不单单是自己如果学的好一点的话薪水可能会高，同时也会有一种自豪感，回家的时候可以说你们经常用到的软件的什么功能是我做出来的，我个人觉得是一件非常有意义的事情。包括现在非常火的自动驾驶、医疗专家系统等等都是为了提高人们的生活水平和改变人们传统的生活方式。<br>&emsp;&emsp;计算机自然也是我擅长的领域。在理论方面，我熟悉基本的数据结构，掌握常用的排序、搜索、查找等算法，对操作系统以及计算机网络都有一个清晰明确的认识并对计算机基本组成原理有深入的学习研究。在工程方面，本科阶段我做的是Java开发，也学过初级的软件工程课，从需求分析、代码编写、单元测试、回归测试等过程我也经常完成，Java集合框架、设计模式、多线程、网络编程、垃圾回收机制、Java虚拟机等我也了解其原理，对一些常用Java框架SpringMVC、Mybatis等能够熟练使用，项目开发过程中使用github作为代码托管工具、一个月至少写两篇技术博客等，这都是我通过上课、实践或者网络等方式学习到的专业技能，这些技能可以支撑我完成计算机领域的一些工作，所以计算机现在是我擅长的领域。但是擅长也不是说我对这个领域达到精通的程度，我对自己也有清晰的认识，计算机领域实在是太宽泛了，我只是在我现在处于的这个阶段达到了计算机从业者的基本资格，还有非常多要学习的地方，相信通过今后的学习，可以把自己变得更好。  </p><h2 id="2-作为研究生的我现在具备和欠缺的知识与技能"><a href="#2-作为研究生的我现在具备和欠缺的知识与技能" class="headerlink" title="2.作为研究生的我现在具备和欠缺的知识与技能"></a>2.作为研究生的我现在具备和欠缺的知识与技能</h2><h3 id="（1）我现在具备的知识与技能："><a href="#（1）我现在具备的知识与技能：" class="headerlink" title="（1）我现在具备的知识与技能："></a>（1）我现在具备的知识与技能：</h3><ul><li>计算机基础：<br>通过在考研的过程中对专业主干课的强化，现在对计算机组成原理、数据结构、计算机网络、操作系统的基本内容有较深的理解； </li><li>数学基础：<br>同样是考研过程中留下的宝贵经验和技能，掌握微积分、矩阵、概率统计等计算机中常用的数学技能；</li><li>英语基础：<br>每天坚持在扇贝单词上背单词打卡在英语流利说上阅读英文原文新闻，目前扇贝已打卡584天,流利说打卡39天，阅读六级和研究生考试难度的文章基本没有障碍；</li><li>项目经验：<br>自己做过国创、科研立项等项目，做过的项目包括web、微信服务号开发、微信小程序、安卓开发等多个方向，对Java语言有较深了解；</li><li>自学能力：<br>项目开发方面的东西比如Java、机器学习、Java项目开发等大多数都来自于自学，自学平台包括慕课网、网易云课堂、腾讯课堂、博客园、csdn等网络学习平台；  <h3 id="（2）我现在缺乏的知识与技能"><a href="#（2）我现在缺乏的知识与技能" class="headerlink" title="（2）我现在缺乏的知识与技能"></a>（2）我现在缺乏的知识与技能</h3></li><li>感兴趣领域的知识框架:<br>我现在想从事的方向是机器学习方向，但是只了解梯度下降、逻辑回归等基本算法，对神经网络和一些非监督学习算法理解不够，对深度学习框架等了解太少,对数据挖掘没有清晰的概念，对于数学上一些比较复杂的公示算法不够了解和熟练；</li><li>英文写作能力：<br>英文写作能力相对薄弱，还不能完成英文论文的写作，既缺乏专业词汇的积累也缺乏英文论文结构的整体把握和行文风格；</li><li>项目中的协作能力：<br>本科阶段没有加入工作室锻炼，做的项目大多数是自己在做，国创的时候图省事把工作都自己做了，对工作安排和分工没有清晰的规划能力；<h2 id="3-我选择的努力方向–工程项目"><a href="#3-我选择的努力方向–工程项目" class="headerlink" title="3.我选择的努力方向–工程项目"></a>3.我选择的努力方向–工程项目</h2><h3 id="（1）我的优势："><a href="#（1）我的优势：" class="headerlink" title="（1）我的优势："></a>（1）我的优势：</h3></li><li>兴趣和热情：<br>我对自己选择的方向很有兴趣也有很大的热情去学习相关内容，有动力也能让我可能比其他人有优势，但是，这只是很小的影响因素，读博客的时候看到过这样一句话，觉得很有道理就写下来了，“兴趣和热情只能让你很执着，但并不一定能让你走好这条路，只有你的能力和你的强项才能让你走好这条路。”所以兴趣和热情在其中的影响远不如能力来的重要，而且大多数情况下二者是相辅相成的，接下来就说能力了；</li><li>计算机基础：<br>数据结构和算法在工程中有极为重要的作用，基础可以使我在工程中更加得心应手；</li><li>项目经验：<br>如上文所说的，我虽然在团队协作上存在不足，但是也有一定的项目经验，对项目的流程相对比较了解；</li><li>自学能力和解决问题的能力：<br>做项目是离不开自学能力的，做项目的过程中会遇到各种困难，之前我的解决办法都是博客，个人觉得博客是极好的平台，项目中的功能实现和出现各种bug的时候博客上基本都有解决方案；</li><li>有很多交流渠道：<br>之前毕业的同学或者学长学姐很多已经入职各个互联网公司，可以向他们请教；<h3 id="（2）我的劣势"><a href="#（2）我的劣势" class="headerlink" title="（2）我的劣势"></a>（2）我的劣势</h3></li><li>可能找不到自己想要的环境：<br>经过多方观察和打听，学院里机器学习与数据挖掘方向的导师基本上都是偏向理论，研一好多导师都不会让进入实验室，这对于那么吃GPU的深度学习、计算机视觉等都是障碍，比较担心理论联系实践的这个过程，所以自己也在导师这块一直纠结；</li><li>时间：<br>最近就开始很明显的感受到时间真的非常紧张，研一课程也不少，还得看各种机器学习的大部头、烧脑的数学，我想研一上完就出去实习，所以每天时间都非常紧张，现在真的后悔本科浪费了太多时间在乱七八糟的事情上；  </li><li>心理上的不自信：<br>考研失败后感觉自己少了很多以往的精气神儿，每天走在学院遇到之前的学弟学妹们都很羞愧，每天都在自我否定中浑浑噩噩，有时候也开始拖延，开始拖泥带水，最近虽然有好转，但是还是跟以前差太多；<h3 id="（3）我在本学期的规划"><a href="#（3）我在本学期的规划" class="headerlink" title="（3）我在本学期的规划"></a>（3）我在本学期的规划</h3></li><li>找一个很好的导师：<br>现在已经这个时候了，希望能找到一个研一可以进实验室的导师：</li><li>把数据结构再过两遍：<br>第一遍重新回忆一下知识点，第二遍把算法都用C语言实现一遍，好几篇博客里都这么说，我想应该很有用；</li><li>使用Python：<br>语言很容易学，但是更容易忘，所以边学边敲，自己做一个小项目最好；</li><li>读书：<br>想把博客里推荐的几本书–《编程之美》、《编程珠玑》、《设计模式》、《计算机程序的构造和解释》、《设计模式》等几本书找个时间认真看一遍；</li><li>参加Imagine Cup：<br>找三个队友和一个指导老师做IC，IC这两年的获奖作品基本上是人工智能+医疗+Azure，我有现成的Azure资源可以用，也可以锻炼自己的编程和团队协作能力；</li><li>有机会的话参加Hackthon：<br>已经找了个其他学校的队友，说有比赛就一起整，不过Hackthon一般都在大城市，到时候也希望他们报销差旅费吧（逃；</li><li>把课程学好：<br>目前上的几门课感觉都挺有用的，应该好好学，成绩现在无所谓了，就看自己能收获多少；</li><li>努力发AAAI：<br>认识一个大佬一年能发接近100篇AAAI，我达不到那种程度，量力而行看看能不能先发一篇试试水，之后有了经验再定新目标；<h2 id="4-我对这门课的期待"><a href="#4-我对这门课的期待" class="headerlink" title="4.我对这门课的期待"></a>4.我对这门课的期待</h2>&emsp;&emsp;听了老师的第一堂课，我的期待当然是可以真正把软件工程学会、学懂，本科阶段学习过软件工程这门课，虽然也会有作业，但是没有现在这么正式，没有这么多作业，之前学的比较枯燥，考试之后基本上也忘得差不多，希望通过这种新的学习方式最后能让自己独立或者能带队完成一个整个的项目，对软件工程的各种模型和方法、流程有深入的了解，在面试的时候能从容不迫。<br>&emsp;&emsp;在写这个博客之前对一周用在这门课上的时间还缺乏一个认识，但是我仅仅完成这一篇博客加上之前的材料阅读已经用了235分钟，接近4个小时的时间，这还是作业比较少的情况，保守估计感觉每周最起码要16个小的时间才能完成基本的课程作业，每天150分钟，总共一周150*7=1050分钟，这是我目前根据实际情况作出的判断，可以再根据下周的情况在多一个训练集的情况下再做个计划。<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2>“是骄傲、虚荣、嫉妒和报复，支撑你走到今天。你的成长依赖这些负的能量，而非天生的善良。”看到这句话挺震撼的，就写在这里了，共勉~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-回想曾经对计算机专业的畅想&quot;&gt;&lt;a href=&quot;#1-回想曾经对计算机专业的畅想&quot; class=&quot;headerlink&quot; title=&quot;1.回想曾经对计算机专业的畅想&quot;&gt;&lt;/a&gt;1.回想曾经对计算机专业的畅想&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;选择计算机专
      
    
    </summary>
    
    
      <category term="SoftwareEngineering" scheme="http://blog.ijunyu.top/tags/SoftwareEngineering/"/>
    
  </entry>
  
  <entry>
    <title>NeuralNetworks</title>
    <link href="http://blog.ijunyu.top/2018/09/06/NeuralNetworks/"/>
    <id>http://blog.ijunyu.top/2018/09/06/NeuralNetworks/</id>
    <published>2018-09-06T06:40:53.000Z</published>
    <updated>2018-09-06T07:40:14.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、神经网络定义"><a href="#一、神经网络定义" class="headerlink" title="一、神经网络定义"></a>一、神经网络定义</h1><p>Origins：Algorithms that try to mimic the brain.Was very widely used in 80s and early 90s;popularity diminished in 90s.<br>Recent resurgence:State-of-the-art technique for many applications.</p><h1 id="二、训练神经网络的方法"><a href="#二、训练神经网络的方法" class="headerlink" title="二、训练神经网络的方法"></a>二、训练神经网络的方法</h1><p>Pick a network architecture(vityconnectivity pattern between neurons)<br>picture-01</p><h2 id="1-Randomly-initialize-weights"><a href="#1-Randomly-initialize-weights" class="headerlink" title="1.Randomly initialize weights;"></a>1.Randomly initialize weights;</h2><p>随机初始化权重</p><h2 id="2-Implement-forward-propagation-to-get-h-Theta-x-i-for-any-x-i"><a href="#2-Implement-forward-propagation-to-get-h-Theta-x-i-for-any-x-i" class="headerlink" title="2.Implement forward propagation to get $ h_\Theta(x^{(i)}) $ for any $ x^{(i)}; $"></a>2.Implement forward propagation to get $ h_\Theta(x^{(i)}) $ for any $ x^{(i)}; $</h2><h2 id="3-Implement-code-to-compute-cost-function-J-Theta"><a href="#3-Implement-code-to-compute-cost-function-J-Theta" class="headerlink" title="3.Implement code to compute cost function $J(\Theta)$"></a>3.Implement code to compute cost function $J(\Theta)$</h2><h2 id="4-Implement-backprop-to-compute-partial-derivatives-frac-∂-∂-Theta-jk-l-J-Theta"><a href="#4-Implement-backprop-to-compute-partial-derivatives-frac-∂-∂-Theta-jk-l-J-Theta" class="headerlink" title="4.Implement backprop to compute partial derivatives $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$"></a>4.Implement backprop to compute partial derivatives $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$</h2><p>for i = 1 : m<br>&nbsp;&nbsp;Perform forward propagation and backpropagation using example($x^{(i)},y^{(i)}$)<br>(Get activations $a^{(l)}$ and delta terms $\delta^{(l)}$ for l = 2,…,L)</p><h2 id="5-Use-gradient-checking-to-compare-frac-∂-∂-Theta-jk-l-J-Theta-compute-using-backpropagation-vs-using-numerical-eatimate-of-gradient-of-J-Theta"><a href="#5-Use-gradient-checking-to-compare-frac-∂-∂-Theta-jk-l-J-Theta-compute-using-backpropagation-vs-using-numerical-eatimate-of-gradient-of-J-Theta" class="headerlink" title="5.Use gradient checking to compare $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$ compute using backpropagation vs. using numerical eatimate of gradient of $J(\Theta)$."></a>5.Use gradient checking to compare $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$ compute using backpropagation vs. using numerical eatimate of gradient of $J(\Theta)$.</h2><p>Then disable gradient checking code.</p><h2 id="6-Use-gradient-descent-of-advanced-optimization-method-with-backpropagation-to-try-to-minimize-J-Theta-as-a-function-of-parameters-Theta"><a href="#6-Use-gradient-descent-of-advanced-optimization-method-with-backpropagation-to-try-to-minimize-J-Theta-as-a-function-of-parameters-Theta" class="headerlink" title="6.Use gradient descent of advanced optimization method with backpropagation to try to minimize $J(\Theta)$ as a function of parameters $\Theta$"></a>6.Use gradient descent of advanced optimization method with backpropagation to try to minimize $J(\Theta)$ as a function of parameters $\Theta$</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、神经网络定义&quot;&gt;&lt;a href=&quot;#一、神经网络定义&quot; class=&quot;headerlink&quot; title=&quot;一、神经网络定义&quot;&gt;&lt;/a&gt;一、神经网络定义&lt;/h1&gt;&lt;p&gt;Origins：Algorithms that try to mimic the brain
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="http://blog.ijunyu.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>Python3.6.5的字符串内建函数</title>
    <link href="http://blog.ijunyu.top/2018/08/11/stringInnerFunctionsInPython/"/>
    <id>http://blog.ijunyu.top/2018/08/11/stringInnerFunctionsInPython/</id>
    <published>2018-08-11T06:27:49.000Z</published>
    <updated>2018-08-11T08:38:25.355Z</updated>
    
    <content type="html"><![CDATA[<p><code>S  = &#39;abcdefghijklmnopqrstuvwxyz&#39;</code>  </p><ol><li><code>S.capitalize() -&gt; str</code><br>Return a capitalized version of S, i.e. make the first character have upper case and the rest lower case.   </li><li><code>S.casefold() -&gt; str</code><br>Return a version of S suitable for caseless comparisons.  </li><li><code>S.center(width[, fillchar]) -&gt; str</code><br>Return S centered in a string of length width. Padding is done using the specified fill character. (default is a space)  </li><li><code>S.count(sub[, start[, end]]) -&gt; int</code><br>Return the number of non-overlapping occurrences of substring sub in string S[start:end].  Optional arguments start and end are interpreted as in slice notation.  </li><li><code>S.encode(encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;) -&gt; bytes</code><br>Encode S using the codec registered for encoding.Default encoding is ‘utf-8’.errors may be given to set a different error handling scheme.Default is ‘strict’ meaning that encoding errors raise a UnicodeEncodeError.Other possible values are ‘ignore’,’replace’and’xmlcharrefreplace’as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.  </li><li><code>S.index(sub[, start[, end]]) -&gt; int</code><br>Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation.Raises ValueError when the substring is not found.  </li><li><code>S.endswith(suffix[, start[, end]]) -&gt; bool</code><br>Return True if S ends with the specified suffix, False otherwise.With optional start, test S beginning at that position.With optional end, stop comparing S at that position.suffix can also be a tuple of strings to try.  </li><li><code>S.expandtabs(tabsize=8) -&gt; str</code><br>Return a copy of S where all tab characters are expanded using spaces.If tabsize is not given, a tab size of 8 characters is assumed.  </li><li><code>S.find(sub[, start[, end]]) -&gt; int</code><br>Return the lowest index in S where substring sub is found,such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation.Return -1 on failure.  </li><li><code>S.format(*args, **kwargs) -&gt; str</code><br>Return a formatted version of S, using substitutions from args and kwargs.The substitutions are identified by braces (‘{‘ and ‘}’).  </li><li><code>S.format_map(mapping) -&gt; str</code><br>Return a formatted version of S, using substitutions from mapping.The substitutions are identified by braces (‘{‘ and ‘}’).Mapping is a type of dict.  </li><li><code>S.isalnum() -&gt; bool</code><br>Return True if all characters in S are alphanumeric and there is at least one character in S, False otherwise.  </li><li><code>S.isalpha() -&gt; bool</code><br>Return True if all characters in S are alphabetic and there is at least one character in S, False otherwise.  </li><li><code>S.isdecimal() -&gt; bool</code><br>Return True if there are only decimal characters in S,False otherwise.  </li><li><code>S.isdigit() -&gt; bool</code><br>Return True if all characters in S are digits and there is at least one character in S, False otherwise.  </li><li><code>S.isidentifier() -&gt; bool</code><br>Return True if S is a valid identifier according to the language definition.Use keyword.iskeyword() to test for reserved identifiers such as “def” and “class”.  </li><li><code>S.islower() -&gt; bool</code><br>Return True if all cased characters in S are lowercase and there is at least one cased character in S, False otherwise.  </li><li><code>S.isnumeric() -&gt; bool</code><br>Return True if there are only numeric characters in S,False otherwise.  </li><li><code>S.isprintable() -&gt; bool</code><br>Return True if all characters in S are considered<br>printable in repr() or S is empty, False otherwise.  </li><li><code>S.isspace() -&gt; bool</code><br>Return True if all characters in S are whitespace and there is at least one character in S, False otherwise.  </li><li><code>S.istitle() -&gt; bool</code><br>Return True if S is a titlecased string and there is at least one character in S, i.e. upper- and titlecase characters may only follow uncased characters and lowercase characters only cased ones.Return False otherwise.  </li><li><code>S.isupper() -&gt; bool</code><br>Return True if all cased characters in S are uppercase and there is at least one cased character in S, False otherwise.  </li><li><code>S.join(iterable) -&gt; str</code><br>Return a string which is the concatenation of the strings in the iterable.The separator between elements is S.  </li><li><code>S.ljust(width[, fillchar]) -&gt; str</code><br>Return S left-justified in a Unicode string of length width. Padding is done using the specified fill character (default is a space).  </li><li><code>S.lower() -&gt; str</code><br>Return a copy of the string S converted to lowercase.  </li><li><code>S.lstrip([chars]) -&gt; str</code><br>Return a copy of the string S with leading whitespace removed.If chars is given and not None, remove characters in chars instead.  </li><li><code>maketrans(x, y=None, z=None, /)</code><br>Return a translation table usable for str.translate().If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None.Character keys will be then converted to ordinals.If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the<br>character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.  </li><li><code>S.partition(sep) -&gt; (head, sep, tail)</code><br>Search for the separator sep in S, and return the part before it,the separator itself, and the part after it.If the separator is not found, return S and two empty strings.  </li><li><code>S.replace(old, new[, count]) -&gt; str</code><br>Return a copy of S with all occurrences of substring<br>old replaced by new.  If the optional argument count is given, only the first count occurrences are replaced.  </li><li><code>S.rfind(sub[, start[, end]]) -&gt; int</code><br>Return the highest index in S where substring sub is found,such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation.Return -1 on failure.  </li><li><code>S.rindex(sub[, start[, end]]) -&gt; int</code><br>Return the highest index in S where substring sub is found,such that sub is contained within S[start:end].  Optionalarguments start and end are interpreted as in slice notation.Raises ValueError when the substring is not found.  </li><li><code>S.rjust(width[, fillchar]) -&gt; str</code><br>Return S right-justified in a string of length width. Padding is done using the specified fill character (default is a space).  </li><li><code>S.rpartition(sep) -&gt; (head, sep, tail)</code><br>Search for the separator sep in S, starting at the end of S, and return the part before it, the separator itself, and the part after it.  If the separator is not found, return two empty strings and S.  </li><li><code>S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings</code><br>Return a list of the words in S, using sep as the<br>delimiter string, starting at the end of the string and working to the front.  If maxsplit is given, at most maxsplit splits are done. If sep is not specified, any whitespace string is a separator.  </li><li><code>S.rstrip([chars]) -&gt; str</code><br>Return a copy of the string S with trailing whitespace removed.If chars is given and not None, remove characters in chars instead.  </li><li><code>S.split(sep=None, maxsplit=-1) -&gt; list of strings</code><br>Return a list of the words in S, using sep as the<br>delimiter string.  If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result.  </li><li><code>S.splitlines([keepends]) -&gt; list of strings</code><br>Return a list of the lines in S, breaking at line boundaries.Line breaks are not included in the resulting list unless keepends is given and true.  </li><li><code>S.startswith(prefix[, start[, end]]) -&gt; bool</code><br>Return True if S starts with the specified prefix, False otherwise.With optional start, test S beginning at that position.With optional end, stop comparing S at that position.prefix can also be a tuple of strings to try.  </li><li><code>S.strip([chars]) -&gt; str</code><br>Return a copy of the string S with leading and trailing whitespace removed.If chars is given and not None, remove characters in chars instead.  </li><li><code>S.swapcase() -&gt; str</code><br>Return a copy of S with uppercase characters converted to lowercase and vice versa.  </li><li><code>S.title() -&gt; str</code><br>Return a titlecased version of S, i.e. words start with title case characters, all remaining cased characters have lower case.  </li><li><code>S.translate(table) -&gt; str</code><br>Return a copy of the string S in which each character has been mapped through the given translation table. The table must implement lookup/indexing via <strong>getitem</strong>, for instance a dictionary or list, mapping Unicode ordinals to Unicode ordinals, strings, or None. If this operation raises LookupError, the character is left untouched.Characters mapped to None are deleted.  </li><li><code>S.upper() -&gt; str</code><br>Return a copy of S converted to uppercase.  </li><li><code>S.zfill(width) -&gt; str</code><br>Pad a numeric string S with zeros on the left, to fill a field of the specified width. The string S is never truncated.  </li><li><code>differences between str.isdigit() and str.isdecimal</code><br>The decimal category includes digit characters.It means that all decimals are digits,but not all digits are decimals.<br>isdigit()<br>True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字<br>False: 汉字数字<br>Error: 无  </li></ol><p>isdecimal()<br>True: Unicode数字，，全角数字（双字节）<br>False: 罗马数字，汉字数字<br>Error: byte数字（单字节）  </p><p>isnumeric()<br>True: Unicode数字，全角数字（双字节），罗马数字，汉字数字<br>False: 无<br>Error: byte数字（单字节）  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;S  = &amp;#39;abcdefghijklmnopqrstuvwxyz&amp;#39;&lt;/code&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;S.capitalize() -&amp;gt; str&lt;/code&gt;&lt;br&gt;Return a capitalized versi
      
    
    </summary>
    
      <category term="理论" scheme="http://blog.ijunyu.top/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="python" scheme="http://blog.ijunyu.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习初级算法</title>
    <link href="http://blog.ijunyu.top/2018/07/26/SummaryOfAlgorithms/"/>
    <id>http://blog.ijunyu.top/2018/07/26/SummaryOfAlgorithms/</id>
    <published>2018-07-26T07:27:05.000Z</published>
    <updated>2018-08-06T07:07:26.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、单变量线性回归-Linear-Regression-with-One-Variable"><a href="#一、单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="一、单变量线性回归(Linear Regression with One Variable)"></a>一、单变量线性回归(Linear Regression with One Variable)</h1><h2 id="1-假设函数-Hypothesis"><a href="#1-假设函数-Hypothesis" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x) = \theta_0 + \theta_1x $$</p><h2 id="2-参数-Parameters"><a href="#2-参数-Parameters" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1 $$</p><h2 id="3-代价函数-Cost-Function"><a href="#3-代价函数-Cost-Function" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$ J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})^2 $$</p><h2 id="4-目标-Goals"><a href="#4-目标-Goals" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$ minimize_{\theta_0,\theta_1} J(\theta_0,\theta_1)$$</p><h2 id="5-解决算法-Solutions"><a href="#5-解决算法-Solutions" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-Gradient-Descent"><a href="#1-梯度下降算法-Gradient-Descent" class="headerlink" title="(1).梯度下降算法(Gradient Descent)"></a>(1).梯度下降算法(Gradient Descent)</h3><h4 id="a-算法内容"><a href="#a-算法内容" class="headerlink" title="a.算法内容"></a>a.算法内容</h4><p>repeat until convergence{<br>    &emsp;$ \theta_j := \theta_j - \alpha \frac{∂}{∂{\theta_j}}J(\theta_0,\theta_1)$<br>}<br>在这里要注意的问题是更新必须是同步更新，具体解释如下：<br>$temp0 := \theta_0-\alpha\frac{∂}{∂\theta_0}J(\theta_0,\theta_1)$<br>$temp1 := \theta_1-\alpha\frac{∂}{∂\theta_1}J(\theta_0,\theta_1)$<br>$\theta_0 := temp0$<br>$\theta_1 := temp1$</p><h4 id="b-线性回归中的梯度下降算法"><a href="#b-线性回归中的梯度下降算法" class="headerlink" title="b.线性回归中的梯度下降算法"></a>b.线性回归中的梯度下降算法</h4><p>$$ h_\theta(x) = \theta_0 + \theta_1x $$<br>$$ J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})^2 $$<br>$$ \frac{∂}{∂\theta_0}J(\theta_0,\theta_1) = \frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)}) $$<br>$$ \frac{∂}{∂\theta_1}J(\theta_0,\theta_1) = \frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x^{(i)} $$<br>Gradient descent algorithm:<br>repeat until convergence{<br>    &emsp;$\theta_0:= \theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})$<br>    &emsp;$\theta_1:= \theta_1-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x^{(i)}$<br>}</p><h1 id="二、多变量线性回归-Linear-Regression-with-Variables"><a href="#二、多变量线性回归-Linear-Regression-with-Variables" class="headerlink" title="二、多变量线性回归(Linear Regression with Variables)"></a>二、多变量线性回归(Linear Regression with Variables)</h1><h2 id="1-假设函数-Hypothesis-1"><a href="#1-假设函数-Hypothesis-1" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + …+\theta_nx_n$$</p><h2 id="2-参数-Parameters-1"><a href="#2-参数-Parameters-1" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1,\theta_2,…,\theta_n $$<br>化为向量形式:$$\overrightarrow{\theta}$$</p><h2 id="3-代价函数-Cost-Function-1"><a href="#3-代价函数-Cost-Function-1" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$J(\theta_0,\theta_1,…\theta_n)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 $$<br>化为向量形式:<br>$$J(\overrightarrow{\theta})=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 $$</p><h2 id="4-目标-Goals-1"><a href="#4-目标-Goals-1" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$ minimize_{\theta_0,\theta_1,…\theta_n} J(\theta_0,\theta_1,…,\theta_n)$$<br>化为向量形式:<br>$$ minimize_{\overrightarrow{\theta}} J(\overrightarrow{\theta})$$</p><h2 id="5-解决算法-Solutions-1"><a href="#5-解决算法-Solutions-1" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-Gradient-Descent-1"><a href="#1-梯度下降算法-Gradient-Descent-1" class="headerlink" title="(1).梯度下降算法(Gradient Descent)"></a>(1).梯度下降算法(Gradient Descent)</h3><p>Gradient descent algorithm:<br>Repeat{<br>&emsp;$\theta_j:= \theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_{j}^{(i)} $<br>&emsp;&emsp;(simultaneously update $\theta_j$ for j=0,1,2,3,…n)<br>}</p><h3 id="2-正规方程-Normal-Equation"><a href="#2-正规方程-Normal-Equation" class="headerlink" title="(2).正规方程(Normal Equation)"></a>(2).正规方程(Normal Equation)</h3><p>m examples($x^{(1)},y^{(1)}$),…,($x^{(m)},y^{(m)}$),n features.<br>$$x^{(i)}=<br>        \begin{pmatrix}<br>        x_{0}^{(i)}\\<br>        x_{1}^{(i)}\\<br>        x_{2}^{(i)}\\<br>        \vdots \\<br>        x_{n}^{(i)}\\<br>        \end{pmatrix}\in R^{n+1}<br>$$<br>令$x^{(i)}_{0}=1,$<br>$$X =<br>        \begin{pmatrix}<br>        (x^{(1)})^T\\<br>        (x^{(2)})^T\\<br>        (x^{(3)})^T\\<br>        \vdots\\<br>        (x^{(m)})^T\\<br>        \end{pmatrix}\in R^{m*(n+1)}<br>$$<br>$$y=<br>        \begin{pmatrix}<br>        y^{(1)} \\<br>        y^{(2)} \\<br>        y^{(3)} \\<br>        \vdots \\<br>        y^{(m)} \\<br>        \end{pmatrix}\in R^{m}<br>$$<br>$$\overrightarrow{\theta} = (X^TX)^{-1}X^Ty$$<br>求出的$\overrightarrow{\theta}$值即为多元线性回归求出的值。</p><h1 id="三、逻辑回归-Logistic-Regression"><a href="#三、逻辑回归-Logistic-Regression" class="headerlink" title="三、逻辑回归(Logistic Regression)"></a>三、逻辑回归(Logistic Regression)</h1><h2 id="1-假设函数-Hypothesis-2"><a href="#1-假设函数-Hypothesis-2" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x)=estimate\ probability\ that\ y=1\ on\ input\ x$$<br>$$h_\theta(x)=g(\theta^Tx)$$<br>$$g(z)=\frac{1}{1+e^{-z}}(sigmoid\ function)$$<br>$$h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$$</p><h2 id="2-参数-Parameters-2"><a href="#2-参数-Parameters-2" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1,…,\theta_n $$</p><h2 id="3-代价函数-Cost-Function-2"><a href="#3-代价函数-Cost-Function-2" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$ J(\theta_0,\theta_1,..,\theta_n) = \frac{1}{m}\sum_{i=1}^{m}\frac{1}{2}(h_\theta(x^{(i)}) - y^{(i)})^2 =\frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y^{(i)})$$<br>其中，<br>$$Cost(h_\theta(x^{(i)}),y^{(i)})=<br>\begin{cases}<br>-log(h_\theta(x)),&amp;\text{if $y$ = 1} \\<br>-log(1-h_\theta(x)),&amp;\text{if $y$ = 0}<br>\end{cases}<br>$$<br>$$Cost(h_\theta(x^{(i)}),y^{(i)})=-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$$<br>所以，<br>$$J(\overrightarrow{\theta})=-\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}log\ h_\theta(x^{(i)})+(1-y^{(i)})log\ (1-h_\theta(x^{(i)}))]$$</p><h2 id="4-目标-Goals-2"><a href="#4-目标-Goals-2" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>(1)$$\min_{\theta}J(\theta)$$<br>(2)$$Output\ h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}$$<br>$$P(y=1|x;\theta)$$</p><h2 id="5-解决算法-Solutions-2"><a href="#5-解决算法-Solutions-2" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法"><a href="#1-梯度下降算法" class="headerlink" title="(1).梯度下降算法"></a>(1).梯度下降算法</h3><p>Repeat{<br>&emsp;$\theta_j:=\theta_j-\alpha\frac{∂}{∂\theta_j}J(\theta)$<br>&emsp;(simultaneously update all $\theta_j$)<br>}<br>化简之后可得，<br>Repeat{<br>&emsp;$\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_{j}^{(i)}$<br>&emsp;(simultaneously update all $\theta_j$)<br>}</p><h3 id="2-高级优化算法-Advanced-Optimization"><a href="#2-高级优化算法-Advanced-Optimization" class="headerlink" title="(2).高级优化算法(Advanced Optimization)"></a>(2).高级优化算法(Advanced Optimization)</h3><p>Example:<br>$$\theta=<br>\begin{pmatrix}<br>\theta_1\\<br>\theta_2\\<br>\end{pmatrix}$$<br>$$J(\theta)=(\theta_1-5)^2+(\theta_2-5)^2$$<br>$$\frac{∂}{∂\theta_1}J(\theta) = 2(\theta_1-5)$$<br>$$\frac{∂}{∂\theta_2}J(\theta) = 2(\theta_2-5)$$<br>costFunction函数代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function [jVal,gradient]</span><br><span class="line">            =costFunction(theta)</span><br><span class="line">    jVal = (theta(1)-5)^2+(theta(2)-5)^2;</span><br><span class="line">    gradient = zeros(2,1);</span><br><span class="line">    gradient(1) = 2*(theta(1)-5);</span><br><span class="line">    gradient(2) = 2*(theta(2)-5);</span><br></pre></td></tr></table></figure></p><p>命令行代码：<br>建立设置集合：<br><code>options = optimset(&#39;GraObj&#39;,&#39;on&#39;,&#39;MaxIter&#39;,&#39;100&#39;);</code><br>设置初试theta数组:<br><code>initialTheta = zeros(2,1);</code><br>调用函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[optTheta,functionVal,exitFlag]</span><br><span class="line">            = fminunc(@costFunction,initialTheta,options);</span><br></pre></td></tr></table></figure></p><p>costFunction的通用代码：<br>$$\theta=<br>\begin{pmatrix}<br>\theta_1\\<br>\theta_2\\<br>\vdots\\<br>\theta_n\\<br>\end{pmatrix}$$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function [jVal,gradient]</span><br><span class="line">            =costFunction(theta)</span><br><span class="line">    jVal = [code to compute J(theta)];</span><br><span class="line">    gradient = zeros(n+1,1);</span><br><span class="line">    gradient(1) = [code to compute ∂/∂theta(0)J(theta)];</span><br><span class="line">    gradient(2) = [code to compute ∂/∂theta(1)J(theta)];</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    gradient(n+1) = [code to compute ∂/∂theta(n)J(theta)];</span><br></pre></td></tr></table></figure></p><h2 id="6-多个分类-Multi-Class-Classification-one-vs-all"><a href="#6-多个分类-Multi-Class-Classification-one-vs-all" class="headerlink" title="6.多个分类(Multi-Class Classification:one-vs-all):"></a>6.多个分类(Multi-Class Classification:one-vs-all):</h2><p>y=1,2,3,4,…<br>$$h_\theta^{(i)}(x)=P(y=i|x;\theta)(i=1,2,3,…)$$</p><h1 id="四、正则化线性回归-Regularized-Linear-Regression"><a href="#四、正则化线性回归-Regularized-Linear-Regression" class="headerlink" title="四、正则化线性回归(Regularized Linear Regression)"></a>四、正则化线性回归(Regularized Linear Regression)</h1><h2 id="1-假设函数-Hypothesis-3"><a href="#1-假设函数-Hypothesis-3" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + …+\theta_nx_n$$</p><h2 id="2-参数-Parameters-3"><a href="#2-参数-Parameters-3" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1,…,\theta_n $$</p><h2 id="3-代价函数-Cost-Function-3"><a href="#3-代价函数-Cost-Function-3" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$J(\theta)=\frac{1}{2m}[\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^n\theta_j^2]$$</p><h2 id="4-目标-Goals-3"><a href="#4-目标-Goals-3" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$\min_{\theta}J(\theta)$$</p><h2 id="5-解决算法-Solutions-3"><a href="#5-解决算法-Solutions-3" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-1"><a href="#1-梯度下降算法-1" class="headerlink" title="(1).梯度下降算法"></a>(1).梯度下降算法</h3><p>Repeat{<br>&emsp;$\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}$<br>&emsp;$\theta_j:=\theta_j-\alpha[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_{j}^{(i)}+\frac{\lambda}{m}{\theta_j}]$<br>&emsp;(simultaneously update all $\theta_j$)<br>}<br>$\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$</p><h3 id="2-正规方程-Normal-Equation-1"><a href="#2-正规方程-Normal-Equation-1" class="headerlink" title="(2).正规方程(Normal Equation)"></a>(2).正规方程(Normal Equation)</h3><p>m examples($x^{(1)},y^{(1)}$),…,($x^{(m)},y^{(m)}$),n features.<br>$$x^{(i)}=<br>        \begin{pmatrix}<br>        x_{0}^{(i)} \\<br>        x_{1}^{(i)} \\<br>        x_{2}^{(i)}\\<br>        \vdots \\<br>        x_{n}^{(i)}\\<br>        \end{pmatrix}\in R^{n+1}<br>$$<br>$$X=<br>\begin{pmatrix}<br>(x^{(1)})^T \\<br>\vdots\\<br>(x^{(m)})^T \\<br>\end{pmatrix}<br>$$<br>$$y=<br>        \begin{pmatrix}<br>        y^{(1)} \\<br>        \vdots \\<br>        y^{(m)} \\<br>        \end{pmatrix}\in R^{m}<br>$$<br>if $\lambda&gt;0$,<br>$$\overrightarrow{\theta} = (X^TX+\lambda<br>\begin{pmatrix}<br>0\\<br>&amp;1\\<br>&amp;&amp;1\\<br>&amp;&amp;&amp;\ddots\\<br>&amp;&amp;&amp;&amp;1<br>\end{pmatrix}<br>)^{-1}X^Ty$$</p><h1 id="五、正则化逻辑回归-Regularized-Logistic-Regression"><a href="#五、正则化逻辑回归-Regularized-Logistic-Regression" class="headerlink" title="五、正则化逻辑回归(Regularized Logistic Regression)"></a>五、正则化逻辑回归(Regularized Logistic Regression)</h1><h2 id="1-假设函数-Hypothesis-4"><a href="#1-假设函数-Hypothesis-4" class="headerlink" title="1.假设函数(Hypothesis)"></a>1.假设函数(Hypothesis)</h2><p>$$h_\theta(x)=g(z),z=f(x,\theta)$$</p><h2 id="2-参数-Parameters-4"><a href="#2-参数-Parameters-4" class="headerlink" title="2.参数(Parameters)"></a>2.参数(Parameters)</h2><p>$$\theta_1,\theta_2,…,\theta_n$$</p><h2 id="3-代价函数-Cost-Function-4"><a href="#3-代价函数-Cost-Function-4" class="headerlink" title="3.代价函数(Cost Function)"></a>3.代价函数(Cost Function)</h2><p>$$J(\theta)=-[\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}\log{h_\theta(x^{(i)})}+(1-y^{(i)})\log{(1-h_\theta(x^{(i)})})]+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta^2_j$$</p><h2 id="4-目标-Goals-4"><a href="#4-目标-Goals-4" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$\min_{\theta}J(\theta)$$</p><h2 id="5-解决算法-Solutions-4"><a href="#5-解决算法-Solutions-4" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-2"><a href="#1-梯度下降算法-2" class="headerlink" title="(1).梯度下降算法"></a>(1).梯度下降算法</h3><p>Repeat{<br>&emsp;$\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}$<br>&emsp;$\theta_j:=\theta_j-\alpha[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_{j}^{(i)}+\frac{\lambda}{m}{\theta_j}]$<br>&emsp;(simultaneously update all $\theta_j$)<br>}<br>$\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$<br>(2)高级优化算法(Advanced Optimization)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function [jVal,gradient]</span><br><span class="line">            =costFunction(theta)</span><br><span class="line">    jVal = [code to compute J(theta)];</span><br><span class="line">    gradient = zeros(n+1,1);</span><br><span class="line">    gradient(1) = [code to compute ∂/∂theta(0)J(theta)];</span><br><span class="line">    gradient(2) = [code to compute ∂/∂theta(1)J(theta)];</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    gradient(n+1) = [code to compute ∂/∂theta(n)J(theta)];</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、单变量线性回归-Linear-Regression-with-One-Variable&quot;&gt;&lt;a href=&quot;#一、单变量线性回归-Linear-Regression-with-One-Variable&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="http://blog.ijunyu.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <link href="http://blog.ijunyu.top/2018/07/22/buildingMyBlogs/"/>
    <id>http://blog.ijunyu.top/2018/07/22/buildingMyBlogs/</id>
    <published>2018-07-22T03:36:21.000Z</published>
    <updated>2018-07-22T08:03:59.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Hexo搭建个人博客"><a href="#利用Hexo搭建个人博客" class="headerlink" title="利用Hexo搭建个人博客"></a>利用Hexo搭建个人博客</h1><p>&emsp;&emsp;Hexo是高效的静态站点生成框架，基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。  </p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-使用工具"><a href="#1-使用工具" class="headerlink" title="1.使用工具"></a>1.使用工具</h3><ul><li>GitHub</li><li>Node.js</li><li>Hexo</li></ul><h3 id="2-本文使用环境"><a href="#2-本文使用环境" class="headerlink" title="2.本文使用环境"></a>2.本文使用环境</h3><ul><li>Windows 10 version 1803</li><li>Git for Windows version 2.17.0</li><li>Node.js version 10.5.0</li><li>Hexo version 3.7.1</li></ul><h3 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3.环境搭建"></a>3.环境搭建</h3><h4 id="1-搭建Node-js环境"><a href="#1-搭建Node-js环境" class="headerlink" title="(1)搭建Node.js环境"></a>(1)搭建Node.js环境</h4><p>&emsp;&emsp;Hexo基于Node.js，Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用，所以先搭建Node.js环境。<br><a href="http://nodejs.cn/download" target="_blank" rel="noopener">Node.js下载地址</a><br><img src="https://i.imgur.com/es0Yi0k.png" alt=""><br>&emsp;&emsp;可以根据自己的需要下载对应的版本，Windows系统下载扩展名为.msi的文件安装即可。<br>&emsp;&emsp;安装完成后在命令行下输入  <code>node -v</code>，如果出现对应的版本号则说明安装成功。<br>新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 <code>npm -v</code> 来测试是否成功安装，出现版本提示表示安装成功:  </p><h4 id="2-安装Git版本工具"><a href="#2-安装Git版本工具" class="headerlink" title="(2)安装Git版本工具"></a>(2)安装Git版本工具</h4><p>&emsp;&emsp;Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。<br><a href="https://git-scm.com/download/" target="_blank" rel="noopener">Git下载地址</a><br>&emsp;&emsp;下载完成后按默认配置安装即可，安装完成后命令行输入 <code>git --version</code>,如果出现对应的版本号则说明安装成功。<br>&emsp;&emsp;安装成功后可以在开始菜单中找到名为git bash的应用图标，此为git的命令行形式，关于hexo的操作今后无特殊说明都是在gitbash下进行。 </p><h4 id="3-注册GitHub账号"><a href="#3-注册GitHub账号" class="headerlink" title="(3)注册GitHub账号"></a>(3)注册GitHub账号</h4><p>&emsp;&emsp;GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。<br><a href="https://github.com" target="_blank" rel="noopener">GitHub注册地址</a><br>&emsp;&emsp;GitHub为英文网站，可以根据提示进行注册操作，如果有不明白的地方可以百度解决，这里要注意的是用户名作为Git上很重要的标识，起名字的时候一定要选择一个合适的名字,我的用户名是zhangjy982，所以进入我个人GitHub的地址为:https:github.com/zhangjy982,下附链接：<a href="https://github.com/zhangjy982" target="_blank" rel="noopener">张俊余的GitHub</a>。  </p><h4 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="(4)安装hexo"></a>(4)安装hexo</h4><p>&emsp;&emsp;前面已经说过，在安装node.js的时候已经将npm集成进去，如果之前测试npm集成成功的话，hexo的安装只需要在gitbash中输入：<br><code>npm install -g hexo</code><br>&emsp;&emsp;等待自动完成后，输入<code>hexo version</code>可以查看hexo对应版本以及判断hexo是否安装成功。</p><h2 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h3><p>&emsp;&emsp;在前面的准备工作中我们已经注册过GitHub账号，接下来要进行的就是在GitHub中创建博客存储的仓库：<br>&emsp;&emsp;第一步，点击新建仓库（new repository）:<br><img src="https://i.imgur.com/1dZ1v7s.png" alt=""><br>&emsp;&emsp;第二步，填写仓库信息，这里最重要的是仓库的名字，要和你的用户名一致，名字的格式为：<code>username.github.io</code>，我为了写这个博客重新注册了一个Git账号：zhangjytest，所以我的仓库名字应该为：<code>zhangjytest.github.io</code>，这样的目的是确定访问地址，以后如果不绑定域名，博客的访问地址就是zhangjytest.github.io了，每个GitHub账户只能创建一个直接使用域名访问的仓库：<br><img src="https://i.imgur.com/4iSlMrT.png" alt=""></p><h3 id="2-配置本地gitbash账户信息"><a href="#2-配置本地gitbash账户信息" class="headerlink" title="2.配置本地gitbash账户信息"></a>2.配置本地gitbash账户信息</h3><p>&emsp;&emsp;为了可以使本地文件上传到Git，需要在gitbash中进行账户信息配置，配置过程如下：<br>&emsp;&emsp;第一步，账户配置，在gitbash下分别输入如下代码：<br><code>git config --global user.name &quot;your name&quot;</code><br><code>git config --global user.email &quot;your email&quot;</code><br><img src="https://i.imgur.com/JY9U7Ft.png" alt=""><br>第二步，创建SSH，在gitbash下输入：<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code><br><img src="https://i.imgur.com/GCGsmsZ.png" alt=""><br>&emsp;&emsp;执行过程中一直按回车键完成执行，执行完毕后会在”C:\Users\zhangjy982.ssh”（zhangjy982为我个人的用户名）文件夹下生成两个文件，分别为<code>id_rsa</code>和<code>id_rsa.pub</code>，用记事本打开<code>id_rsa.pub</code>文件，复制其中全部内容。<br>&emsp;&emsp;第三步，将获取的SSH设置到GitHub中：<br>&emsp;&emsp;进入设置页面：<br><img src="https://i.imgur.com/fvGl6ES.png" alt=""><br>&emsp;&emsp;在设置中找到SSH and GPG keys中的add SSH，将复制下来的字符串复制到Key中，Title值可以是任意值：<br><img src="https://i.imgur.com/Goc53dv.png" alt=""><br>&emsp;&emsp;第四步，在gitbash中验证是否成功：<br><code>ssh -T git@github.com</code><br>&emsp;&emsp;如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes后如下图所示：<br><img src="https://i.imgur.com/UqTrTAI.png" alt=""><br>&emsp;&emsp;此时gitbash的配置也已经完成。</p><h3 id="2-利用hexo写博客"><a href="#2-利用hexo写博客" class="headerlink" title="2.利用hexo写博客"></a>2.利用hexo写博客</h3><p>&emsp;&emsp;第一步，安装过程已经在环境搭建步骤中完成。<br>&emsp;&emsp;第二步，初始化，在你想要存放本地blog文件的地方新建文件夹MyBlogs（文件名字可任意），比如我的是C：\Users\zhangjy982\MyBlogs,先进入文件夹:<code>cd &quot;C:\Users\zhangjy982\MyBlogs&quot;</code>,<br><img src="https://i.imgur.com/mzqZFRu.png" alt=""><br>&emsp;&emsp;然后输入：<code>hexo init</code>,hexo就会自动下载一些到该文件夹，过程可能稍慢，耐心等待，<br><img src="https://i.imgur.com/nrtHsCI.png" alt=""><br>文件夹解释:  </p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息<br>&emsp;&emsp;第三步，提交到服务器，<code>hexo s</code>命令可以启动本地localhost服务，默认启动4000端口，启动后如图，Ctrl+C可以关闭服务。<br><img src="https://i.imgur.com/OfyqIJI.png" alt=""><br>&emsp;&emsp;第四步，打开浏览器，地址栏输入：<code>http://localhost:4000</code>,即可展示默认的博客界面，默认博客已经有一篇helloworld的博客，所以效果是下面这样的，如果你出现了下面这个页面，说明你已经成功了一大半了。<br><img src="https://i.imgur.com/6cvi5IK.png" alt=""><br>&emsp;&emsp;第五步，到目前为止，呈现出的网页还是本地的，那么如何上传到GitHub，继而可以通过域名访问呢，很简单，只需要几个简单的命令就可以，我们首先先介绍一下常用的几个命令：<br>(1)<code>hexo g</code><br>此命令可以生成静态页面到public文件夹；<br>(2)<code>hexo d</code><br>此命令可以将静态页面部署到服务器端，进而可以实现域名访问；<br>(3)<code>hexo g -d</code><br>此命令可以完成生成静态页面后部署到服务器的全过程；<br>(4)<code>hexo d -g</code><br>此命令是部署之前预先生成静态文件；<br>(5)<code>hexo clean</code><br>此命令是将之前生成的静态页面删除，适用于更改配置文件之后重新生成静态文件之前的操作，可以把旧的静态文件删除；<br>&emsp;&emsp;除此之外，还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：<br><img src="https://i.imgur.com/pxZayiF.png" alt=""><br>&emsp;&emsp;然后修改本地博客目录的配置，即修改_config.yml文件，修改yml文件的时候需注意utf-8的格式要求，写字板和记事本等软件会改变文件的编码格式，建议使用sublime等工具，修改deploy配置如下：<br><img src="https://i.imgur.com/4mkVMYJ.png" alt=""><br>&emsp;&emsp;保存完配置文件之后，随后需要安装部署插件：<code>npm install hexo-deployer-git —save</code><br>最后，在gitbash下直接输入<code>hexo clean</code>可以将博客之前生成的静态页面清楚，然后输入<code>hexo g -d</code>完成博客上传，以实现域名访问，此时的访问域名为<code>zhangjytest.github.io</code> 得到的页面和之前的本地访问页面是一致的。 <h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2>&emsp;&emsp;本文主要介绍了hexo搭建个人博客的最基础的过程，至此，已经完成了博客的初步搭建，但是后续还有写新博客，博客主题更改，博客文章分类，博客访问人数统计，博客字数展示，博客阅读时间估计等基本内容，后续的文章中会继续介绍整个过程。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用Hexo搭建个人博客&quot;&gt;&lt;a href=&quot;#利用Hexo搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;利用Hexo搭建个人博客&quot;&gt;&lt;/a&gt;利用Hexo搭建个人博客&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Hexo是高效的静态站点生成框架，基
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.ijunyu.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://blog.ijunyu.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Octive基本操作</title>
    <link href="http://blog.ijunyu.top/2018/07/20/Octive/"/>
    <id>http://blog.ijunyu.top/2018/07/20/Octive/</id>
    <published>2018-07-20T11:48:53.000Z</published>
    <updated>2018-07-20T14:44:11.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Octive基本操作"><a href="#Octive基本操作" class="headerlink" title="Octive基本操作"></a>Octive基本操作</h1><h2 id="一、基本运算"><a href="#一、基本运算" class="headerlink" title="一、基本运算"></a>一、基本运算</h2><h3 id="1-基本四则运算"><a href="#1-基本四则运算" class="headerlink" title="1.基本四则运算"></a>1.基本四则运算</h3><p>(1)5+6<br>加法运算，ans = 11；<br>(2)6-9<br>减法运算，ans = -3；<br>(3)65*8<br>乘法运算，ans = 520；<br>(4)23/8<br>除法运算，ans = 2.87500000000000；<br>(5)4^6<br>乘方运算，ans = 4096；<br>(6)sqrt(10)<br>平方根运算，ans = 3.16227766016838；</p><h3 id="2-逻辑运算"><a href="#2-逻辑运算" class="headerlink" title="2.逻辑运算"></a>2.逻辑运算</h3><p>(1)1 == 2<br>判断相等，ans = 0；<br>(2)1 ~=2<br>判断不等，ans = 1；<br>(3)1 &amp;&amp; 0<br>判断逻辑与，ans = 0；<br>(4)1 || 0<br>判断逻辑或，ans = 1；<br>(5)xor(1,0)<br>判断异或，ans = 1；</p><h2 id="二、基本函数"><a href="#二、基本函数" class="headerlink" title="二、基本函数"></a>二、基本函数</h2><p>(1)disp(a)<br>展示变量信息；<br>(2)disp(sprintf(‘2 decimals: %0.2f’,a))：<br>显示字符串变量，其中格式和c类似；<br>(3)PS1(‘&gt;&gt; ‘)<br>更改左边显示样式；<br>(4)format long/short<br>数据格式更改；<br>(5)hist(w)<br>将矩阵表示的分布用直方图显示出来，其中w为服从高斯分布的数据组成的矩阵;<br>(6)hist(w,50)<br>可以指定生成的直方图的方格的数量；</p><h2 id="三、矩阵表示"><a href="#三、矩阵表示" class="headerlink" title="三、矩阵表示"></a>三、矩阵表示</h2><h3 id="1-普通表示"><a href="#1-普通表示" class="headerlink" title="1.普通表示"></a>1.普通表示</h3><p>(1)A = [1 2;3 4;5 6]<br>表示一个3x2的矩阵，分号表示一行；</p><h3 id="2-行向量表示"><a href="#2-行向量表示" class="headerlink" title="2.行向量表示"></a>2.行向量表示</h3><p>(1)V = 1：0.1：2<br>表示从1开始每次增加0.1，最大到2的行向量；<br>(2)V = 1：6<br>表示1 2 3 4 5 6组成的行向量；</p><h3 id="3-特殊函数表示"><a href="#3-特殊函数表示" class="headerlink" title="3.特殊函数表示"></a>3.特殊函数表示</h3><p>(1)W = ones（2，3）<br>表示只包含1的一个2行3列矩阵；<br>(2)W = 2*ones（2，3）<br>表示只包含2的2行3列矩阵；<br>(3)W = rand（1，3）<br>表示包含0-1之间随机小数的1行3列矩阵；<br>(4)W = randn（2，3）<br>表示服从高斯分布，标准差或者方差为1的数据组成的2行3列矩阵；</p><h3 id="4-单位矩阵表示"><a href="#4-单位矩阵表示" class="headerlink" title="4.单位矩阵表示"></a>4.单位矩阵表示</h3><p>(1).E = eye（4）表示生成4x4的单位矩阵；</p><h2 id="四、移动数据"><a href="#四、移动数据" class="headerlink" title="四、移动数据"></a>四、移动数据</h2><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h3><p>(1)size(A)<br>返回矩阵A的各个维度数目的行向量，ans = 3 2；<br>(2)size(A,1)<br>返回矩阵A的第一维数目，ans = 3；<br>(3)size(A,2)<br>返回矩阵A的第二维数目，ans = 2；<br>(4)length(V)<br>返回矩阵的各个维度中的最大值，通常用于返回向量的维度值，ans = 4；<br>(5)load featuresX.dat<br>加载数据文件，加载完成后生成与文件名相同名字的变量；<br>(5)load(‘featuresX.dat’)<br>加载数据文件的另一种方法；<br>(6)who<br>显示所有变量；<br>(7)whos<br>显示所有变量及其详细信息；<br>(8)clear featuresX<br>删除变量；<br>(9)v = featuresX(1:10)<br>将featuresX中第一列数据的1-10个赋值给变量v；<br>(10)save hello.mat v<br>使变量v保存为一个名为hello.mat的文件，该文件使用二进制压缩的方式存储；<br>(11)clear<br>删除当前工作空间中的所有变量；<br>(12)load hello.mat<br>加载之前生成的文件，加载完成后变量v重新自动出现；<br>(13)save hello.txt v -ascii<br>将变量v保存为一个名为hello.txt的文本文件；</p><h3 id="2-数据获取及移动（A-1-2-3-4-5-6-）"><a href="#2-数据获取及移动（A-1-2-3-4-5-6-）" class="headerlink" title="2.数据获取及移动（A = [1 2 ; 3 4 ; 5 6]）"></a>2.数据获取及移动（A = [1 2 ; 3 4 ; 5 6]）</h3><p>(1) A(3,2)<br>返回矩阵A第三行第二列的元素，ans = 6；<br>(2)A(2,:)<br>返回第二行所有元素；<br>(3)A(:,2)<br>返回第二列所有元素；<br>(4)A([1 3],:)<br>返回第一行和第三行所有元素；<br>(5)A(:,2) = [10;11;12]<br>将矩阵A的第二列重新赋值；<br>(6)A = (A,[100;101;102])<br>为矩阵A增加一列新的向量；<br>(7)A = (A;[1 3])<br>为矩阵A增加一行新的向量；<br>(8)A(:)<br>将矩阵A中的所有元素形成一个列向量；<br>(9)C = [A B]<br>将矩阵A与矩阵B横向合并；<br>(10)C = [A,B]<br>将矩阵A与矩阵B横向合并；<br>(11)C = [A;B]<br>将矩阵A与矩阵B纵向合并；</p><h2 id="五、矩阵数据计算"><a href="#五、矩阵数据计算" class="headerlink" title="五、矩阵数据计算"></a>五、矩阵数据计算</h2><h3 id="1-矩阵基本运算-A-1-2-3-4-5-6-v-1-15-2-0-5"><a href="#1-矩阵基本运算-A-1-2-3-4-5-6-v-1-15-2-0-5" class="headerlink" title="1.矩阵基本运算(A  = [1 2 ;3 4;5 6],v = [1 15 2 0.5])"></a>1.矩阵基本运算(A  = [1 2 ;3 4;5 6],v = [1 15 2 0.5])</h3><p>(1)A <em> B<br>矩阵乘法，按照正常的矩阵乘法流程运算，运算结果是线性代数矩阵相乘结果；<br>(2)A .</em> B<br>矩阵A和矩阵B的各项分别相乘，必须是同型矩阵才可以相乘，点号通常用于表示元素之间的运算；<br>(3)A .^ 2<br>矩阵A中的每一个元素都做乘方2的运算；<br>(4)1 ./ A<br>矩阵A中的每一个元素都取倒数；<br>(5)log(A)<br>矩阵A中的每一个元素取log值；<br>(6)exp(A)<br>以e为底数，A中元素为指数的幂运算，结果仍为矩阵；<br>(7)abs(A)<br>将矩阵A中的每一个元素都取其绝对值，结果仍为矩阵；<br>(8)-A<br>将矩阵中的每一个元素都取其相反数，结果仍为矩阵；<br>(9)v + ones(length(v),1)<br>将v中的每一个元素都加1；<br>(10)v + 1<br>将v中的每一个元素都加1；<br>(11)A’<br>A的转置；<br>(12)A&lt;3<br>将矩阵A中的每一个元素和3比较如果满足小于3的条件置一，否则置零，最后形成一个和A同型的矩阵，<br>矩阵的每个元素是0或者1；</p><h3 id="2-矩阵运算中的部分重要函数-A-magic-4"><a href="#2-矩阵运算中的部分重要函数-A-magic-4" class="headerlink" title="2.矩阵运算中的部分重要函数(A=magic(4))"></a>2.矩阵运算中的部分重要函数(A=magic(4))</h3><p>(1)magic(4)<br>生成一个幻方矩阵，幻方矩阵的特点的特点是每一行、每一列和对角线上的元素加起来数值相等；<br>(2)max函数<br>a.[val,ind] = max(A)<br>val返回每一列中最大的元素值，并组成一个行向量，ind返回最大元素值的索引值，并组成一个行向量；<br>b.max(A,[],1)<br>返回每一列中的最大元素值，并组成一个行向量；<br>c.max(A,[],2)<br>返回每一行中的最大元素值，并组成一个列向量；<br>d.val = max(A)<br>将val赋值为每一列最大值组成的行向量；<br>e.max(max(A))<br>返回矩阵中的最大值；<br>f.max(A(:))<br>先将矩阵A中的所有元素转为列向量之后取最大值，也是起到取矩阵最大值的效果；<br>(3)find(A&lt;3)<br>返回矩阵A 中元素值小于3的索引，产生顺序为按照列进行，结果为一个列向量；<br>(4)[r,c] = find(A&lt;=7)<br>查找矩阵A 中小于等于7的所有元素的索引，r为行索引，c为列索引，查找顺序按照列进行；<br>(5)sum函数<br>a.sum(A)<br>将矩阵A中每一列的元素值求和，返回求和值组成的一个行向量，向量维度和A的列数相等；<br>b.sum(A,1)<br>将矩阵A中每一列的元素值求和，返回求和值组成的一个行向量，向量维度和A的列数相等；<br>c.sum(A,2)<br>将矩阵A中每一行的元素值求和，返回求和值组成的一个列向量，向量维度和A的行数相等；<br>d.sum(sum(A .<em> eye(4)))<br>返回矩阵A正对角线元素之和；<br>e.sum(sum(A .</em>flipud(eye(4))))<br>返回矩阵A反对角线元素之和；<br>(6)flipud(A)<br>使矩阵A垂直翻转，即最后一行变成第一行，倒数第二行变成第二行，倒数第三行变成第三行，以此类推；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Octive基本操作&quot;&gt;&lt;a href=&quot;#Octive基本操作&quot; class=&quot;headerlink&quot; title=&quot;Octive基本操作&quot;&gt;&lt;/a&gt;Octive基本操作&lt;/h1&gt;&lt;h2 id=&quot;一、基本运算&quot;&gt;&lt;a href=&quot;#一、基本运算&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.ijunyu.top/2018/07/06/hello-world/"/>
    <id>http://blog.ijunyu.top/2018/07/06/hello-world/</id>
    <published>2018-07-06T13:53:01.050Z</published>
    <updated>2018-09-20T06:11:56.744Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: [Deployment](<a href="https://hexo.io/docs/deployment" target="_blank" rel="noopener">https://hexo.io/docs/deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
