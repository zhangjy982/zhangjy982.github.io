<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俊余的博客</title>
  
  <subtitle>东北师范大学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ijunyu.top/"/>
  <updated>2018-09-20T06:11:44.876Z</updated>
  <id>http://blog.ijunyu.top/</id>
  
  <author>
    <name>Junyu Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>py2exe</title>
    <link href="http://blog.ijunyu.top/2018/09/20/py2exe/"/>
    <id>http://blog.ijunyu.top/2018/09/20/py2exe/</id>
    <published>2018-09-20T05:14:41.000Z</published>
    <updated>2018-09-20T06:11:44.876Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在最近的软件工程作业中用到了将Python脚本转化为exe文件这一过程，网上各种博客介绍了很多，有些东西都不完全，我也是综合了很多种方法最后才实现的，我就把这些整理出来，希望可以帮到大家~</p><h1 id="一、环境和工具"><a href="#一、环境和工具" class="headerlink" title="一、环境和工具"></a>一、环境和工具</h1><ul><li>Windows 10 Enterprise 64bit</li><li>Python 3.6.4</li><li>pyinstaller</li><li>pip 18.0<h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><h2 id="1-pip安装pyinstaller"><a href="#1-pip安装pyinstaller" class="headerlink" title="1. pip安装pyinstaller"></a>1. pip安装pyinstaller</h2><h3 id="1-Python和pip的使用"><a href="#1-Python和pip的使用" class="headerlink" title="(1).Python和pip的使用"></a>(1).Python和pip的使用</h3>pip类似于linux中的yumy，但它是依赖于Python的，如果你已经成功安装Python相关版本并且配置好环境变量，就可以使用pip进行软件安装。在cmd下输入<code>python</code>如果出现对应的版本等信息，说明是安装成功的；同样，cmd下输入<code>pip</code>如果弹出来很多帮助信息也说明pip是可用的；更多安装相关内容可以百度，这里不赘述。<h3 id="2-安装pyinstaller"><a href="#2-安装pyinstaller" class="headerlink" title="(2).安装pyinstaller"></a>(2).安装pyinstaller</h3>&emsp;&emsp;首先，进入Python安装目录的Scripts文件夹下，如果你忘记了Python的安装位置，可以通过命令行的方式显示安装路径。具体操作为：cmd下输入python进入Python编辑器环境，然后输入代码：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path</span><br></pre></td></tr></table></figure></li></ul><p>我的Python安装路径是：C:\Users\zhang\AppData\Programs\Python\Python36文件夹下，那么我的安装路径查看效果如下图所示：<br><img src="https://i.imgur.com/IJvOGkN.png" alt=""><br>输入：<br><code>cd C:\Users\zhang\AppData\Local\Programs\Python\Python36\Scripts\</code><br>进入Python的Scripts文件夹。<br>&emsp;&emsp;然后，在cmd中输入命令：<br><code>pip.exe install Pyinstaller</code>，<br>接下来会完成pyinstaller的安装,安装完成后在Scripts文件夹中会出现pyinstaller.exe，说明安装成功。<br>&emsp;&emsp;最后，通过命令行的方式实现Python脚本到exe的转换，命令格式为：<br><code>pyinstaller.exe [-parameter] filename</code>，其中[-parameter]共有三个参数，<code>-w</code>参数k可以屏蔽m命令行调试窗口；<code>-F</code>参数可以把脚本打包成一个独立的exe文件,否则是一个带各种dll和依赖文件的文件夹；<code>-p</code>参数可以增加pyinstaller搜索模块的路径，这里我们使用<code>-F</code>参数就可以满足需要。filename参数是要打包的脚本文件的完全路径，比如我的脚本文件wf.py放在<code>C:\Users\zhang\source\repos\wc\wc</code>文件夹下，那我我的filename的值就是：<code>C:\Users\zhang\source\repos\wc\wc\wf.py</code><br>&emsp;&emsp;所以，我要输入的命令就是：<br><code>pyinstaller.exe -F C:\Users\zhang\source\repos\wc\wc\wf.py</code><br>&emsp;&emsp;执行完毕后在Scripts文件下会生成一个dist文件夹，dist文件夹就存放着刚生成的wf.exe文件，至此，py2exe的整个过程就结束了，我们也实现了目标。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在最近的软件工程作业中用到了将Python脚本转化为exe文件这一过程，网上各种博客介绍了很多，有些东西都不完全，我也是综合了很多种方法最后才实现的，我就把这些整理出来，希望可以帮到大家~&lt;/p&gt;
&lt;h1 id=&quot;一、环境和工具&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://blog.ijunyu.top/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>homework</title>
    <link href="http://blog.ijunyu.top/2018/09/17/homework/"/>
    <id>http://blog.ijunyu.top/2018/09/17/homework/</id>
    <published>2018-09-16T18:35:51.000Z</published>
    <updated>2018-09-16T18:37:27.553Z</updated>
    
    <content type="html"><![CDATA[<p>此作业的要求参见[<a href="https://edu.cnblogs.com/campus/nenu/2018fall/homework/2101]。" target="_blank" rel="noopener">https://edu.cnblogs.com/campus/nenu/2018fall/homework/2101]。</a></p><h1 id="2018091-2-博客作业-1"><a href="#2018091-2-博客作业-1" class="headerlink" title="2018091-2 博客作业-1"></a>2018091-2 博客作业-1</h1><p>&emsp;&emsp;1.在博客园已建立博客；<br>&emsp;&emsp;2.已关注杨贵福；</p><h1 id="2018091-2-博客作业-2"><a href="#2018091-2-博客作业-2" class="headerlink" title="2018091-2 博客作业-2"></a>2018091-2 博客作业-2</h1><h2 id="1-回想曾经对计算机专业的畅想"><a href="#1-回想曾经对计算机专业的畅想" class="headerlink" title="1.回想曾经对计算机专业的畅想"></a>1.回想曾经对计算机专业的畅想</h2><p>&emsp;&emsp;选择计算机专业其实也是比较偶然吧，因为是被调剂到软件工程专业的。当时高考成绩不太理想，距离理想的学校差距很大，当时正好山东开始有了平行志愿，前几个都报的有点高了，家里那时候挺想让我当老师的，就让我填个师范学校，其实当时也是为了敷衍一下他们就填了东北师大，也没想到前三个都没过，就被东北师大录了，师范专业分还不够，然后就被调剂到了软件工程。其实之前对计算机专业了解的真的很少，基本上仅限于高中学的很少的Basic语言。<br>&emsp;&emsp;之前有段时间特别喜欢刷知乎，所以对轮子哥还是非常欣赏甚至崇拜的（逃，一开始对于计算机的期待大概就是做一个像轮子哥一样的程序员大佬，按他的说法就是没那个难就进了微软，根据自己的兴趣爱好做项目，做编译器，老师推荐的博客里轮子哥的那篇博客之前也在朋友圈里被好多人转发过，我想应该很多人最开始对程序员的一种向往就是轮子哥那种吧。学院的课程是否和期待的一样，我感觉在我心里还是有一个变化的过程的，开始觉得数据结构、C语言、操作系统等课程以后在工程上用的很少，甚至在网站开发上有些东西根本用不到，离自己期待的还有些远，后来才慢慢发现工程代码也不是纯粹的写各种代码，还是要有思想在里面的，后来大三的时候也面试过好多公司，那时候是真的切实的意识到基础课的重要性，我还很清楚的记得第一次面试的时候面试官问了一个关于进程的问题我就只有印象却什么说不出来的窘境，所以那次面试也非常的惨，我估计面试官也还绝望吧。现在回想一下，特别是在看完几个大佬的博客之后，觉得对于现在的我来说，学院的课程基本上应该是符合期待的，这些都是在以后能用得上的，但是遗憾的是当时没有意识到这个问题，所以现在应该再去回顾一下这些基础课，亡羊补牢，为时未晚，共勉吧!<br>&emsp;&emsp;对于现在的我来说，计算机当时是我喜欢的领域，我觉得计算机现在是最能改变人们生活方式的一个行业，本科时候潘老师经常跟我们说，做项目的想法有很多，随时观察身边的事物就不愁项目没有想法，如果觉得生活中有什么事或者什么方式你觉得不方便，就可以去想是不是可以通过编程的方式去解决，如果可以，就进一步去挖掘这个想法的潜在价值，这样一个项目就可以进行下去了。之后做的国创或者科研立项等等都是在生活的基础上进行的，做过店铺排队的系统，也做过商场的服务APP，我觉得这些都是做出来能对周围人的生活产生积极的影响的，我觉得这个行业很有价值，这个价值不单单是自己如果学的好一点的话薪水可能会高，同时也会有一种自豪感，回家的时候可以说你们经常用到的软件的什么功能是我做出来的，我个人觉得是一件非常有意义的事情。包括现在非常火的自动驾驶、医疗专家系统等等都是为了提高人们的生活水平和改变人们传统的生活方式。<br>&emsp;&emsp;计算机自然也是我擅长的领域。在理论方面，我熟悉基本的数据结构，掌握常用的排序、搜索、查找等算法，对操作系统以及计算机网络都有一个清晰明确的认识并对计算机基本组成原理有深入的学习研究。在工程方面，本科阶段我做的是Java开发，也学过初级的软件工程课，从需求分析、代码编写、单元测试、回归测试等过程我也经常完成，Java集合框架、设计模式、多线程、网络编程、垃圾回收机制、Java虚拟机等我也了解其原理，对一些常用Java框架SpringMVC、Mybatis等能够熟练使用，项目开发过程中使用github作为代码托管工具、一个月至少写两篇技术博客等，这都是我通过上课、实践或者网络等方式学习到的专业技能，这些技能可以支撑我完成计算机领域的一些工作，所以计算机现在是我擅长的领域。但是擅长也不是说我对这个领域达到精通的程度，我对自己也有清晰的认识，计算机领域实在是太宽泛了，我只是在我现在处于的这个阶段达到了计算机从业者的基本资格，还有非常多要学习的地方，相信通过今后的学习，可以把自己变得更好。  </p><h2 id="2-作为研究生的我现在具备和欠缺的知识与技能"><a href="#2-作为研究生的我现在具备和欠缺的知识与技能" class="headerlink" title="2.作为研究生的我现在具备和欠缺的知识与技能"></a>2.作为研究生的我现在具备和欠缺的知识与技能</h2><h3 id="（1）我现在具备的知识与技能："><a href="#（1）我现在具备的知识与技能：" class="headerlink" title="（1）我现在具备的知识与技能："></a>（1）我现在具备的知识与技能：</h3><ul><li>计算机基础：<br>通过在考研的过程中对专业主干课的强化，现在对计算机组成原理、数据结构、计算机网络、操作系统的基本内容有较深的理解； </li><li>数学基础：<br>同样是考研过程中留下的宝贵经验和技能，掌握微积分、矩阵、概率统计等计算机中常用的数学技能；</li><li>英语基础：<br>每天坚持在扇贝单词上背单词打卡在英语流利说上阅读英文原文新闻，目前扇贝已打卡584天,流利说打卡39天，阅读六级和研究生考试难度的文章基本没有障碍；</li><li>项目经验：<br>自己做过国创、科研立项等项目，做过的项目包括web、微信服务号开发、微信小程序、安卓开发等多个方向，对Java语言有较深了解；</li><li>自学能力：<br>项目开发方面的东西比如Java、机器学习、Java项目开发等大多数都来自于自学，自学平台包括慕课网、网易云课堂、腾讯课堂、博客园、csdn等网络学习平台；  <h3 id="（2）我现在缺乏的知识与技能"><a href="#（2）我现在缺乏的知识与技能" class="headerlink" title="（2）我现在缺乏的知识与技能"></a>（2）我现在缺乏的知识与技能</h3></li><li>感兴趣领域的知识框架:<br>我现在想从事的方向是机器学习方向，但是只了解梯度下降、逻辑回归等基本算法，对神经网络和一些非监督学习算法理解不够，对深度学习框架等了解太少,对数据挖掘没有清晰的概念，对于数学上一些比较复杂的公示算法不够了解和熟练；</li><li>英文写作能力：<br>英文写作能力相对薄弱，还不能完成英文论文的写作，既缺乏专业词汇的积累也缺乏英文论文结构的整体把握和行文风格；</li><li>项目中的协作能力：<br>本科阶段没有加入工作室锻炼，做的项目大多数是自己在做，国创的时候图省事把工作都自己做了，对工作安排和分工没有清晰的规划能力；<h2 id="3-我选择的努力方向–工程项目"><a href="#3-我选择的努力方向–工程项目" class="headerlink" title="3.我选择的努力方向–工程项目"></a>3.我选择的努力方向–工程项目</h2><h3 id="（1）我的优势："><a href="#（1）我的优势：" class="headerlink" title="（1）我的优势："></a>（1）我的优势：</h3></li><li>兴趣和热情：<br>我对自己选择的方向很有兴趣也有很大的热情去学习相关内容，有动力也能让我可能比其他人有优势，但是，这只是很小的影响因素，读博客的时候看到过这样一句话，觉得很有道理就写下来了，“兴趣和热情只能让你很执着，但并不一定能让你走好这条路，只有你的能力和你的强项才能让你走好这条路。”所以兴趣和热情在其中的影响远不如能力来的重要，而且大多数情况下二者是相辅相成的，接下来就说能力了；</li><li>计算机基础：<br>数据结构和算法在工程中有极为重要的作用，基础可以使我在工程中更加得心应手；</li><li>项目经验：<br>如上文所说的，我虽然在团队协作上存在不足，但是也有一定的项目经验，对项目的流程相对比较了解；</li><li>自学能力和解决问题的能力：<br>做项目是离不开自学能力的，做项目的过程中会遇到各种困难，之前我的解决办法都是博客，个人觉得博客是极好的平台，项目中的功能实现和出现各种bug的时候博客上基本都有解决方案；</li><li>有很多交流渠道：<br>之前毕业的同学或者学长学姐很多已经入职各个互联网公司，可以向他们请教；<h3 id="（2）我的劣势"><a href="#（2）我的劣势" class="headerlink" title="（2）我的劣势"></a>（2）我的劣势</h3></li><li>可能找不到自己想要的环境：<br>经过多方观察和打听，学院里机器学习与数据挖掘方向的导师基本上都是偏向理论，研一好多导师都不会让进入实验室，这对于那么吃GPU的深度学习、计算机视觉等都是障碍，比较担心理论联系实践的这个过程，所以自己也在导师这块一直纠结；</li><li>时间：<br>最近就开始很明显的感受到时间真的非常紧张，研一课程也不少，还得看各种机器学习的大部头、烧脑的数学，我想研一上完就出去实习，所以每天时间都非常紧张，现在真的后悔本科浪费了太多时间在乱七八糟的事情上；  </li><li>心理上的不自信：<br>考研失败后感觉自己少了很多以往的精气神儿，每天走在学院遇到之前的学弟学妹们都很羞愧，每天都在自我否定中浑浑噩噩，有时候也开始拖延，开始拖泥带水，最近虽然有好转，但是还是跟以前差太多；<h3 id="（3）我在本学期的规划"><a href="#（3）我在本学期的规划" class="headerlink" title="（3）我在本学期的规划"></a>（3）我在本学期的规划</h3></li><li>找一个很好的导师：<br>现在已经这个时候了，希望能找到一个研一可以进实验室的导师：</li><li>把数据结构再过两遍：<br>第一遍重新回忆一下知识点，第二遍把算法都用C语言实现一遍，好几篇博客里都这么说，我想应该很有用；</li><li>使用Python：<br>语言很容易学，但是更容易忘，所以边学边敲，自己做一个小项目最好；</li><li>读书：<br>想把博客里推荐的几本书–《编程之美》、《编程珠玑》、《设计模式》、《计算机程序的构造和解释》、《设计模式》等几本书找个时间认真看一遍；</li><li>参加Imagine Cup：<br>找三个队友和一个指导老师做IC，IC这两年的获奖作品基本上是人工智能+医疗+Azure，我有现成的Azure资源可以用，也可以锻炼自己的编程和团队协作能力；</li><li>有机会的话参加Hackthon：<br>已经找了个其他学校的队友，说有比赛就一起整，不过Hackthon一般都在大城市，到时候也希望他们报销差旅费吧（逃；</li><li>把课程学好：<br>目前上的几门课感觉都挺有用的，应该好好学，成绩现在无所谓了，就看自己能收获多少；</li><li>努力发AAAI：<br>认识一个大佬一年能发接近100篇AAAI，我达不到那种程度，量力而行看看能不能先发一篇试试水，之后有了经验再定新目标；<h2 id="4-我对这门课的期待"><a href="#4-我对这门课的期待" class="headerlink" title="4.我对这门课的期待"></a>4.我对这门课的期待</h2>&emsp;&emsp;听了老师的第一堂课，我的期待当然是可以真正把软件工程学会、学懂，本科阶段学习过软件工程这门课，虽然也会有作业，但是没有现在这么正式，没有这么多作业，之前学的比较枯燥，考试之后基本上也忘得差不多，希望通过这种新的学习方式最后能让自己独立或者能带队完成一个整个的项目，对软件工程的各种模型和方法、流程有深入的了解，在面试的时候能从容不迫。<br>&emsp;&emsp;在写这个博客之前对一周用在这门课上的时间还缺乏一个认识，但是我仅仅完成这一篇博客加上之前的材料阅读已经用了235分钟，接近4个小时的时间，这还是作业比较少的情况，保守估计感觉每周最起码要16个小的时间才能完成基本的课程作业，每天150分钟，总共一周150*7=1050分钟，这是我目前根据实际情况作出的判断，可以再根据下周的情况在多一个训练集的情况下再做个计划。<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2>“是骄傲、虚荣、嫉妒和报复，支撑你走到今天。你的成长依赖这些负的能量，而非天生的善良。”看到这句话挺震撼的，就写在这里了，共勉~<h1 id="2018091-2-博客作业-3"><a href="#2018091-2-博客作业-3" class="headerlink" title="2018091-2 博客作业-3"></a>2018091-2 博客作业-3</h1>&emsp;&emsp;一周的时间读完整本《构建之法》，也很难非常细致的提出问题，我就把我在读的过程中遇到的问题写出来，也不仅仅包括理论的内容，在按照书中的实践要求进行操作的时候，我也遇到了不少问题，下面是我的几个问题。<br>&emsp;&emsp;1.书中第二章介绍效能分析的名词解释时，对Exclusive Time的解释为：所有在本函数花费的时间，不包括被调用者使用的时间，与之区别的Inclusive Time在书中的解释为：包含本函数和所有调用者使用的时间。从字面上看，Exclusive和Inclusive应该有对应相关的意思，也就是后面是否包含的时间应该是同一个时间，但是书中的解释前者是不包括被调用者使用的时间，后者是所有调用者的时间，二者又不是对应的，我看的时候就闹不清到底是调用者还是被调用者的时间，所以就搜索了一下，以下解释来源于微软官方文档：”Exclusive time is the amount of excution time that passed while within that function excluding the time spent in functions called from that function.”,”Inclusive time is the amount of excution time that passed while within that function including the time spent in functions called from that function.”结果和我预想的一样，二者是excluding和including的区别，再根据文档中的说明，这里应该都是被调用者的时间。<br>&emsp;&emsp;2.在完成命令行执行一个C++程序的实践作业时，我忘记了怎么操作，所以在谷歌上搜了一下，里面的方法是使用VS里的cl对C++程序进行编译处理，我照做之后发现并不可以，一本基本的HelloWorld程序都编译不出来，说缺少必要文件，于是我根据报错内容继续配置机器的各种环境，最后无果。然后我就想直接用VS跑一下试试，结果，还是标准的C++的HelloWorld程序，只有一个头文件iostream，结果报错出了1294条错误，之后也看了各种博客，试了各种方法，都没用，最后就采用了一个很极端的方法，把VS卸载了重装解决了问题，所以想问一下老师，这是出了什么问题？以后出了这种问题，应该到什么地方去寻求帮助呢？<br>&emsp;&emsp;3.书中的第4、5章主要说了两人合作以及团队和流程，与人合作的过程中难免会出现各种各样的问题，比如在两人合作的磨合阶段，这段时间是从笨拙到规范转变的重要过程，加之可能结对的人基础就相差甚远，出现的矛盾会更多，在这个阶段应该怎样合理的处理这些矛盾才能使磨合阶段尽快过去呢？<br>&emsp;&emsp;4.还是团队合作的一个问题，之前就很困扰我，书中说了好多软件团队的模式，其中有一个叫做主治医师模式：就像在手术台上那样，有一个主刀医师，其他人各司其职，为主刀医师服务。但这样就退化为“一个学生干活，其余学生跟着打酱油”这种现象。从我的个人经历来看，本科的时候从做国创、科研立项,到各种编程的课堂作业，都非常频繁的陷入到这种模式的弊端当中，团队中只有少数人做事，剩下的都比较消极，想着坐享其成。既然有这种模式存在，那么有没有什么比较有效的方法可以杜绝这种不好的风气和习惯呢？<br>&emsp;&emsp;5.在第7章的充分授权和信任一节中说到：在一个高效的团队中，所有的成员都应该得到充分的授权，他们有权在职权范围内按照自己的承诺完成任务，同时，他们也充分信任其他同事能实现各自的承诺。但往往事与愿违，在公司可能还能完成的比较顺畅，但是在学校范围内，这一点就变得很难，本科时候有课程是要完成一个网站设计，也是分工完成，但确实就有同学明明知道自己的任务是什么，却不想去完成，但为了最后拿到一个好的成绩，往往会有一个人自愿代替他完成，在这种习惯下以后的任务就很难继续分配下去，那么这个时候的充分授权和信任就很难实现，这种信任是不是要有某种前提？如何能培养出这种信任感？<h1 id="2018091-2-博客作业-4"><a href="#2018091-2-博客作业-4" class="headerlink" title="2018091-2 博客作业-4"></a>2018091-2 博客作业-4</h1><h2 id="能力1："><a href="#能力1：" class="headerlink" title="能力1："></a>能力1：</h2>&emsp;&emsp;想了半天也没想出什么除了体重之外其他能超过周围的人的，反而想到了好多落后于他们的，那我的技能可不可以是明明有190斤但却看不出有那么重，看着就跟160似的；<h2 id="能力2："><a href="#能力2：" class="headerlink" title="能力2："></a>能力2：</h2>&emsp;&emsp;另一个就是我在扇贝打卡的天数应该能超过90%的人，直到今天（2018年9月13日）总共为584天；<h2 id="能力3："><a href="#能力3：" class="headerlink" title="能力3："></a>能力3：</h2>&emsp;&emsp;抖个机灵，据我所知，咱班应该没有MSP（微软校园精英）,那我就是独一无二的了，作为一个MSP认识了天南海北的大佬，向大佬们学习，每年还能去IC中国赛区总决赛观摩学习，还可以参加Ignite大会，参观centerOne什么的；<h2 id="能力4："><a href="#能力4：" class="headerlink" title="能力4："></a>能力4：</h2>&emsp;&emsp;托MSP的福，可以有vs企业版订阅和每月$150的Azure额度，班里90%的人没有自己搭服务器科学上网，所以我还是fb和ins的活跃用户（逃，吃完晚饭还跟一个忘了怎么加的好友的摩洛哥老哥尬聊了20分钟；如果没记错的话，我还有czh的fb好友；<h2 id="能力5："><a href="#能力5：" class="headerlink" title="能力5："></a>能力5：</h2>&emsp;&emsp;90%的人都没有我关注邹老师的微博早，刚加入MSP的时候广加MSP好友的时候就通过某种微博的推荐机制关注了邹老师的微博，大家也可以关注@程序员邹欣，邹老师的微博还是蛮有意思的；<br>&emsp;&emsp;这种抖机灵的能力还是蛮多的，就不抖下去了了；<h1 id="2018091-2-博客作业-5"><a href="#2018091-2-博客作业-5" class="headerlink" title="2018091-2 博客作业-5"></a>2018091-2 博客作业-5</h1>&emsp;&emsp;经过多方打听和沟通，有幸采访到了徐绍斌学长，学长他们小组当时做的项目是一个贪吃蛇的游戏，学长也很热情的接受了我的采访，以下是采访过程；<br>&emsp;&emsp;张：当时的项目有多少用户，给用户多少价值？ 现在还有人用吗?<br>&emsp;&emsp;徐：当时做完用户还稍微多一点，那会大家都比较好奇我们做的贪吃蛇到底是什么样的，所以除了组内开发的同学，周围的同学也都玩过我们的这个游戏；因为我们做的是游戏嘛，给用户的价值我觉得除了休闲娱乐之外就是让大家觉得做游戏相关的东西没有那么难，我们自己也可以做出游戏来；现在没人用了，因为你也知道，贪吃蛇大家都玩过，经过一段时间之后兴趣就消退了。<br>&emsp;&emsp;张：这个项目能否给我们团队继续开发，源代码/文档还有么?<br>&emsp;&emsp;徐：当然可以了，你们可以拿过去继续用或者看看，代码放在GitHub上，不过我建议你们做一个新的，毕竟贪吃蛇继续开发的空间可能没有那么的大；<br>&emsp;&emsp;张：项目开发有什么经验和教训？<br>&emsp;&emsp;徐：当时我们组7个人，5个人都没有什么做项目的经验，所以花了挺多时间学习项目的整个流程，我估计你们到时候也差不多是这种情况，你们组之前有经  验的可以带一带其他人，初期多交流开发流程和想法，后期效率能高很多。<br>&emsp;&emsp;张：对学好软件工程有什么建议？<br>&emsp;&emsp;徐：多看看构建之法那本书，在做开发的时候把自己做的和书上说的对应起来，让步骤明确，每一步该做些啥尽量心中有数，整个过程做下来你们会有很多收获的。<br>&emsp;&emsp;以上内容省略寒暄感谢过程，在这里再次感谢学长。<h1 id="2018091-2-博客作业-6"><a href="#2018091-2-博客作业-6" class="headerlink" title="2018091-2 博客作业-6"></a>2018091-2 博客作业-6</h1>&emsp;&emsp;说来惭愧，现在代码量也就5000行代码，这些里甚至包括Java的各种类的编写、数据库字段名等非逻辑代码，以前做的项目实在是太少了；<br>&emsp;&emsp;个人觉得优秀的和一般的计算机专业学生为了有资格入职互联网公司需要的有效代码行数最起码是20000和10000行有效代码的；<br>&emsp;&emsp;本课程结束希望自己能再写5000行有效代码，那种练习语法的自然是除外的，整个课程18周，每周需要的平均代码量为300行有效代码；<h1 id="2018091-2-博客作业-7"><a href="#2018091-2-博客作业-7" class="headerlink" title="2018091-2 博客作业-7"></a>2018091-2 博客作业-7</h1><h2 id="关于上课认真听讲和师生关系的阅读心得"><a href="#关于上课认真听讲和师生关系的阅读心得" class="headerlink" title="关于上课认真听讲和师生关系的阅读心得"></a>关于上课认真听讲和师生关系的阅读心得</h2>&emsp;&emsp;上课认真听讲这事，找一个班的小学生和同等人数的大学生班级作比较，我觉得可能小学生会表现的更好一点。似乎一直都有这样一个现象，在大学这个本该比其他时候心智更成熟、做事更稳重的时期，更多人放弃了之前的各种优良习惯，晚睡晚起、上课玩手机似乎有点成了许多大学生的常态，我也是俗人一个，也是这些颓废大学生中的一员，想想自己当时为什么不努力，我也反思过很久，得出的结论就是自制力太差，自己太懒，又缺乏一种责任感。好习惯的养成需要时间，懒散确很容易，我还记得我们高中语文老师给我们讲过关于垃圾堆的道理，大概是这么说的，一个地方，如果一直是干净的，那么它能保持整洁很长时间，在某一个时间，有人往那块扔了一片垃圾，那么很快，周围的人都会以为那是个垃圾堆，都往同一个地方扔垃圾，过不了多久，那个地方就真的变成了垃圾堆。人的坏习惯也是如此，可能我们第一次不认真听讲就是因为小点点小事耽误了中间的一小段时间，就像微博里有人说过的段子，上课的时候不小心笔掉了，低了个头去捡，数学课就再也没听懂过。我反而觉得这挺真实的，这一小段时间就是最开始的那一点垃圾，你扔过去了没捡起来，久而久之，就变成了垃圾桶，就离大神们远了很多。更久之后,就真的丧失了专注的能力。现在正值开学，每次开学都会有很多人立下各种壮志豪言，上课也都能认真听讲，但是过了一周、两周、n周之后又是该干嘛干嘛去了，不知道有没有人能有耐心读我写的又臭又长的博客，如果看到这里的话，我希望我们可以一起履行现在做的承诺和规划，一点一点再把好习惯找回来，还是那句话吧，共勉~<br>&emsp;&emsp;关于师生关系，我也非常赞同教练和学员的关系，我觉得这种关系除了文章中说的那些之外，还有一个相似之处就是健身很多情况下也是开始很有劲头，但是过了一两周之后就丧失了激情，开始觉得健身很累，很难坚持，就放弃了，当然这只是个题外话，一笑而过就好。当然更希望我能够做一个努力的学员把自己练的好一点，生活中也是如此，最近非常热衷于减肥，要是在现实中的健身能一直保持专注也是极好的！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此作业的要求参见[&lt;a href=&quot;https://edu.cnblogs.com/campus/nenu/2018fall/homework/2101]。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://edu.cnblogs.com/ca
      
    
    </summary>
    
    
      <category term="SoftwareEngineering" scheme="http://blog.ijunyu.top/tags/SoftwareEngineering/"/>
    
  </entry>
  
  <entry>
    <title>NeuralNetworks</title>
    <link href="http://blog.ijunyu.top/2018/09/06/NeuralNetworks/"/>
    <id>http://blog.ijunyu.top/2018/09/06/NeuralNetworks/</id>
    <published>2018-09-06T06:40:53.000Z</published>
    <updated>2018-09-06T07:40:14.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、神经网络定义"><a href="#一、神经网络定义" class="headerlink" title="一、神经网络定义"></a>一、神经网络定义</h1><p>Origins：Algorithms that try to mimic the brain.Was very widely used in 80s and early 90s;popularity diminished in 90s.<br>Recent resurgence:State-of-the-art technique for many applications.</p><h1 id="二、训练神经网络的方法"><a href="#二、训练神经网络的方法" class="headerlink" title="二、训练神经网络的方法"></a>二、训练神经网络的方法</h1><p>Pick a network architecture(vityconnectivity pattern between neurons)<br>picture-01</p><h2 id="1-Randomly-initialize-weights"><a href="#1-Randomly-initialize-weights" class="headerlink" title="1.Randomly initialize weights;"></a>1.Randomly initialize weights;</h2><p>随机初始化权重</p><h2 id="2-Implement-forward-propagation-to-get-h-Theta-x-i-for-any-x-i"><a href="#2-Implement-forward-propagation-to-get-h-Theta-x-i-for-any-x-i" class="headerlink" title="2.Implement forward propagation to get $ h_\Theta(x^{(i)}) $ for any $ x^{(i)}; $"></a>2.Implement forward propagation to get $ h_\Theta(x^{(i)}) $ for any $ x^{(i)}; $</h2><h2 id="3-Implement-code-to-compute-cost-function-J-Theta"><a href="#3-Implement-code-to-compute-cost-function-J-Theta" class="headerlink" title="3.Implement code to compute cost function $J(\Theta)$"></a>3.Implement code to compute cost function $J(\Theta)$</h2><h2 id="4-Implement-backprop-to-compute-partial-derivatives-frac-∂-∂-Theta-jk-l-J-Theta"><a href="#4-Implement-backprop-to-compute-partial-derivatives-frac-∂-∂-Theta-jk-l-J-Theta" class="headerlink" title="4.Implement backprop to compute partial derivatives $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$"></a>4.Implement backprop to compute partial derivatives $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$</h2><p>for i = 1 : m<br>&nbsp;&nbsp;Perform forward propagation and backpropagation using example($x^{(i)},y^{(i)}$)<br>(Get activations $a^{(l)}$ and delta terms $\delta^{(l)}$ for l = 2,…,L)</p><h2 id="5-Use-gradient-checking-to-compare-frac-∂-∂-Theta-jk-l-J-Theta-compute-using-backpropagation-vs-using-numerical-eatimate-of-gradient-of-J-Theta"><a href="#5-Use-gradient-checking-to-compare-frac-∂-∂-Theta-jk-l-J-Theta-compute-using-backpropagation-vs-using-numerical-eatimate-of-gradient-of-J-Theta" class="headerlink" title="5.Use gradient checking to compare $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$ compute using backpropagation vs. using numerical eatimate of gradient of $J(\Theta)$."></a>5.Use gradient checking to compare $\frac{∂}{∂\Theta_{jk}^{(l)}}J(\Theta)$ compute using backpropagation vs. using numerical eatimate of gradient of $J(\Theta)$.</h2><p>Then disable gradient checking code.</p><h2 id="6-Use-gradient-descent-of-advanced-optimization-method-with-backpropagation-to-try-to-minimize-J-Theta-as-a-function-of-parameters-Theta"><a href="#6-Use-gradient-descent-of-advanced-optimization-method-with-backpropagation-to-try-to-minimize-J-Theta-as-a-function-of-parameters-Theta" class="headerlink" title="6.Use gradient descent of advanced optimization method with backpropagation to try to minimize $J(\Theta)$ as a function of parameters $\Theta$"></a>6.Use gradient descent of advanced optimization method with backpropagation to try to minimize $J(\Theta)$ as a function of parameters $\Theta$</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、神经网络定义&quot;&gt;&lt;a href=&quot;#一、神经网络定义&quot; class=&quot;headerlink&quot; title=&quot;一、神经网络定义&quot;&gt;&lt;/a&gt;一、神经网络定义&lt;/h1&gt;&lt;p&gt;Origins：Algorithms that try to mimic the brain
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="http://blog.ijunyu.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>Python3.6.5的字符串内建函数</title>
    <link href="http://blog.ijunyu.top/2018/08/11/stringInnerFunctionsInPython/"/>
    <id>http://blog.ijunyu.top/2018/08/11/stringInnerFunctionsInPython/</id>
    <published>2018-08-11T06:27:49.000Z</published>
    <updated>2018-08-11T08:38:25.355Z</updated>
    
    <content type="html"><![CDATA[<p><code>S  = &#39;abcdefghijklmnopqrstuvwxyz&#39;</code>  </p><ol><li><code>S.capitalize() -&gt; str</code><br>Return a capitalized version of S, i.e. make the first character have upper case and the rest lower case.   </li><li><code>S.casefold() -&gt; str</code><br>Return a version of S suitable for caseless comparisons.  </li><li><code>S.center(width[, fillchar]) -&gt; str</code><br>Return S centered in a string of length width. Padding is done using the specified fill character. (default is a space)  </li><li><code>S.count(sub[, start[, end]]) -&gt; int</code><br>Return the number of non-overlapping occurrences of substring sub in string S[start:end].  Optional arguments start and end are interpreted as in slice notation.  </li><li><code>S.encode(encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;) -&gt; bytes</code><br>Encode S using the codec registered for encoding.Default encoding is ‘utf-8’.errors may be given to set a different error handling scheme.Default is ‘strict’ meaning that encoding errors raise a UnicodeEncodeError.Other possible values are ‘ignore’,’replace’and’xmlcharrefreplace’as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.  </li><li><code>S.index(sub[, start[, end]]) -&gt; int</code><br>Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation.Raises ValueError when the substring is not found.  </li><li><code>S.endswith(suffix[, start[, end]]) -&gt; bool</code><br>Return True if S ends with the specified suffix, False otherwise.With optional start, test S beginning at that position.With optional end, stop comparing S at that position.suffix can also be a tuple of strings to try.  </li><li><code>S.expandtabs(tabsize=8) -&gt; str</code><br>Return a copy of S where all tab characters are expanded using spaces.If tabsize is not given, a tab size of 8 characters is assumed.  </li><li><code>S.find(sub[, start[, end]]) -&gt; int</code><br>Return the lowest index in S where substring sub is found,such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation.Return -1 on failure.  </li><li><code>S.format(*args, **kwargs) -&gt; str</code><br>Return a formatted version of S, using substitutions from args and kwargs.The substitutions are identified by braces (‘{‘ and ‘}’).  </li><li><code>S.format_map(mapping) -&gt; str</code><br>Return a formatted version of S, using substitutions from mapping.The substitutions are identified by braces (‘{‘ and ‘}’).Mapping is a type of dict.  </li><li><code>S.isalnum() -&gt; bool</code><br>Return True if all characters in S are alphanumeric and there is at least one character in S, False otherwise.  </li><li><code>S.isalpha() -&gt; bool</code><br>Return True if all characters in S are alphabetic and there is at least one character in S, False otherwise.  </li><li><code>S.isdecimal() -&gt; bool</code><br>Return True if there are only decimal characters in S,False otherwise.  </li><li><code>S.isdigit() -&gt; bool</code><br>Return True if all characters in S are digits and there is at least one character in S, False otherwise.  </li><li><code>S.isidentifier() -&gt; bool</code><br>Return True if S is a valid identifier according to the language definition.Use keyword.iskeyword() to test for reserved identifiers such as “def” and “class”.  </li><li><code>S.islower() -&gt; bool</code><br>Return True if all cased characters in S are lowercase and there is at least one cased character in S, False otherwise.  </li><li><code>S.isnumeric() -&gt; bool</code><br>Return True if there are only numeric characters in S,False otherwise.  </li><li><code>S.isprintable() -&gt; bool</code><br>Return True if all characters in S are considered<br>printable in repr() or S is empty, False otherwise.  </li><li><code>S.isspace() -&gt; bool</code><br>Return True if all characters in S are whitespace and there is at least one character in S, False otherwise.  </li><li><code>S.istitle() -&gt; bool</code><br>Return True if S is a titlecased string and there is at least one character in S, i.e. upper- and titlecase characters may only follow uncased characters and lowercase characters only cased ones.Return False otherwise.  </li><li><code>S.isupper() -&gt; bool</code><br>Return True if all cased characters in S are uppercase and there is at least one cased character in S, False otherwise.  </li><li><code>S.join(iterable) -&gt; str</code><br>Return a string which is the concatenation of the strings in the iterable.The separator between elements is S.  </li><li><code>S.ljust(width[, fillchar]) -&gt; str</code><br>Return S left-justified in a Unicode string of length width. Padding is done using the specified fill character (default is a space).  </li><li><code>S.lower() -&gt; str</code><br>Return a copy of the string S converted to lowercase.  </li><li><code>S.lstrip([chars]) -&gt; str</code><br>Return a copy of the string S with leading whitespace removed.If chars is given and not None, remove characters in chars instead.  </li><li><code>maketrans(x, y=None, z=None, /)</code><br>Return a translation table usable for str.translate().If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None.Character keys will be then converted to ordinals.If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the<br>character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.  </li><li><code>S.partition(sep) -&gt; (head, sep, tail)</code><br>Search for the separator sep in S, and return the part before it,the separator itself, and the part after it.If the separator is not found, return S and two empty strings.  </li><li><code>S.replace(old, new[, count]) -&gt; str</code><br>Return a copy of S with all occurrences of substring<br>old replaced by new.  If the optional argument count is given, only the first count occurrences are replaced.  </li><li><code>S.rfind(sub[, start[, end]]) -&gt; int</code><br>Return the highest index in S where substring sub is found,such that sub is contained within S[start:end].  Optional arguments start and end are interpreted as in slice notation.Return -1 on failure.  </li><li><code>S.rindex(sub[, start[, end]]) -&gt; int</code><br>Return the highest index in S where substring sub is found,such that sub is contained within S[start:end].  Optionalarguments start and end are interpreted as in slice notation.Raises ValueError when the substring is not found.  </li><li><code>S.rjust(width[, fillchar]) -&gt; str</code><br>Return S right-justified in a string of length width. Padding is done using the specified fill character (default is a space).  </li><li><code>S.rpartition(sep) -&gt; (head, sep, tail)</code><br>Search for the separator sep in S, starting at the end of S, and return the part before it, the separator itself, and the part after it.  If the separator is not found, return two empty strings and S.  </li><li><code>S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings</code><br>Return a list of the words in S, using sep as the<br>delimiter string, starting at the end of the string and working to the front.  If maxsplit is given, at most maxsplit splits are done. If sep is not specified, any whitespace string is a separator.  </li><li><code>S.rstrip([chars]) -&gt; str</code><br>Return a copy of the string S with trailing whitespace removed.If chars is given and not None, remove characters in chars instead.  </li><li><code>S.split(sep=None, maxsplit=-1) -&gt; list of strings</code><br>Return a list of the words in S, using sep as the<br>delimiter string.  If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result.  </li><li><code>S.splitlines([keepends]) -&gt; list of strings</code><br>Return a list of the lines in S, breaking at line boundaries.Line breaks are not included in the resulting list unless keepends is given and true.  </li><li><code>S.startswith(prefix[, start[, end]]) -&gt; bool</code><br>Return True if S starts with the specified prefix, False otherwise.With optional start, test S beginning at that position.With optional end, stop comparing S at that position.prefix can also be a tuple of strings to try.  </li><li><code>S.strip([chars]) -&gt; str</code><br>Return a copy of the string S with leading and trailing whitespace removed.If chars is given and not None, remove characters in chars instead.  </li><li><code>S.swapcase() -&gt; str</code><br>Return a copy of S with uppercase characters converted to lowercase and vice versa.  </li><li><code>S.title() -&gt; str</code><br>Return a titlecased version of S, i.e. words start with title case characters, all remaining cased characters have lower case.  </li><li><code>S.translate(table) -&gt; str</code><br>Return a copy of the string S in which each character has been mapped through the given translation table. The table must implement lookup/indexing via <strong>getitem</strong>, for instance a dictionary or list, mapping Unicode ordinals to Unicode ordinals, strings, or None. If this operation raises LookupError, the character is left untouched.Characters mapped to None are deleted.  </li><li><code>S.upper() -&gt; str</code><br>Return a copy of S converted to uppercase.  </li><li><code>S.zfill(width) -&gt; str</code><br>Pad a numeric string S with zeros on the left, to fill a field of the specified width. The string S is never truncated.  </li><li><code>differences between str.isdigit() and str.isdecimal</code><br>The decimal category includes digit characters.It means that all decimals are digits,but not all digits are decimals.<br>isdigit()<br>True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字<br>False: 汉字数字<br>Error: 无  </li></ol><p>isdecimal()<br>True: Unicode数字，，全角数字（双字节）<br>False: 罗马数字，汉字数字<br>Error: byte数字（单字节）  </p><p>isnumeric()<br>True: Unicode数字，全角数字（双字节），罗马数字，汉字数字<br>False: 无<br>Error: byte数字（单字节）  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;S  = &amp;#39;abcdefghijklmnopqrstuvwxyz&amp;#39;&lt;/code&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;S.capitalize() -&amp;gt; str&lt;/code&gt;&lt;br&gt;Return a capitalized versi
      
    
    </summary>
    
      <category term="理论" scheme="http://blog.ijunyu.top/categories/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="python" scheme="http://blog.ijunyu.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习初级算法</title>
    <link href="http://blog.ijunyu.top/2018/07/26/SummaryOfAlgorithms/"/>
    <id>http://blog.ijunyu.top/2018/07/26/SummaryOfAlgorithms/</id>
    <published>2018-07-26T07:27:05.000Z</published>
    <updated>2018-08-06T07:07:26.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、单变量线性回归-Linear-Regression-with-One-Variable"><a href="#一、单变量线性回归-Linear-Regression-with-One-Variable" class="headerlink" title="一、单变量线性回归(Linear Regression with One Variable)"></a>一、单变量线性回归(Linear Regression with One Variable)</h1><h2 id="1-假设函数-Hypothesis"><a href="#1-假设函数-Hypothesis" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x) = \theta_0 + \theta_1x $$</p><h2 id="2-参数-Parameters"><a href="#2-参数-Parameters" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1 $$</p><h2 id="3-代价函数-Cost-Function"><a href="#3-代价函数-Cost-Function" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$ J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})^2 $$</p><h2 id="4-目标-Goals"><a href="#4-目标-Goals" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$ minimize_{\theta_0,\theta_1} J(\theta_0,\theta_1)$$</p><h2 id="5-解决算法-Solutions"><a href="#5-解决算法-Solutions" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-Gradient-Descent"><a href="#1-梯度下降算法-Gradient-Descent" class="headerlink" title="(1).梯度下降算法(Gradient Descent)"></a>(1).梯度下降算法(Gradient Descent)</h3><h4 id="a-算法内容"><a href="#a-算法内容" class="headerlink" title="a.算法内容"></a>a.算法内容</h4><p>repeat until convergence{<br>    &emsp;$ \theta_j := \theta_j - \alpha \frac{∂}{∂{\theta_j}}J(\theta_0,\theta_1)$<br>}<br>在这里要注意的问题是更新必须是同步更新，具体解释如下：<br>$temp0 := \theta_0-\alpha\frac{∂}{∂\theta_0}J(\theta_0,\theta_1)$<br>$temp1 := \theta_1-\alpha\frac{∂}{∂\theta_1}J(\theta_0,\theta_1)$<br>$\theta_0 := temp0$<br>$\theta_1 := temp1$</p><h4 id="b-线性回归中的梯度下降算法"><a href="#b-线性回归中的梯度下降算法" class="headerlink" title="b.线性回归中的梯度下降算法"></a>b.线性回归中的梯度下降算法</h4><p>$$ h_\theta(x) = \theta_0 + \theta_1x $$<br>$$ J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})^2 $$<br>$$ \frac{∂}{∂\theta_0}J(\theta_0,\theta_1) = \frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)}) $$<br>$$ \frac{∂}{∂\theta_1}J(\theta_0,\theta_1) = \frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x^{(i)} $$<br>Gradient descent algorithm:<br>repeat until convergence{<br>    &emsp;$\theta_0:= \theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})$<br>    &emsp;$\theta_1:= \theta_1-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x^{(i)}$<br>}</p><h1 id="二、多变量线性回归-Linear-Regression-with-Variables"><a href="#二、多变量线性回归-Linear-Regression-with-Variables" class="headerlink" title="二、多变量线性回归(Linear Regression with Variables)"></a>二、多变量线性回归(Linear Regression with Variables)</h1><h2 id="1-假设函数-Hypothesis-1"><a href="#1-假设函数-Hypothesis-1" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + …+\theta_nx_n$$</p><h2 id="2-参数-Parameters-1"><a href="#2-参数-Parameters-1" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1,\theta_2,…,\theta_n $$<br>化为向量形式:$$\overrightarrow{\theta}$$</p><h2 id="3-代价函数-Cost-Function-1"><a href="#3-代价函数-Cost-Function-1" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$J(\theta_0,\theta_1,…\theta_n)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 $$<br>化为向量形式:<br>$$J(\overrightarrow{\theta})=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 $$</p><h2 id="4-目标-Goals-1"><a href="#4-目标-Goals-1" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$ minimize_{\theta_0,\theta_1,…\theta_n} J(\theta_0,\theta_1,…,\theta_n)$$<br>化为向量形式:<br>$$ minimize_{\overrightarrow{\theta}} J(\overrightarrow{\theta})$$</p><h2 id="5-解决算法-Solutions-1"><a href="#5-解决算法-Solutions-1" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-Gradient-Descent-1"><a href="#1-梯度下降算法-Gradient-Descent-1" class="headerlink" title="(1).梯度下降算法(Gradient Descent)"></a>(1).梯度下降算法(Gradient Descent)</h3><p>Gradient descent algorithm:<br>Repeat{<br>&emsp;$\theta_j:= \theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})x_{j}^{(i)} $<br>&emsp;&emsp;(simultaneously update $\theta_j$ for j=0,1,2,3,…n)<br>}</p><h3 id="2-正规方程-Normal-Equation"><a href="#2-正规方程-Normal-Equation" class="headerlink" title="(2).正规方程(Normal Equation)"></a>(2).正规方程(Normal Equation)</h3><p>m examples($x^{(1)},y^{(1)}$),…,($x^{(m)},y^{(m)}$),n features.<br>$$x^{(i)}=<br>        \begin{pmatrix}<br>        x_{0}^{(i)}\\<br>        x_{1}^{(i)}\\<br>        x_{2}^{(i)}\\<br>        \vdots \\<br>        x_{n}^{(i)}\\<br>        \end{pmatrix}\in R^{n+1}<br>$$<br>令$x^{(i)}_{0}=1,$<br>$$X =<br>        \begin{pmatrix}<br>        (x^{(1)})^T\\<br>        (x^{(2)})^T\\<br>        (x^{(3)})^T\\<br>        \vdots\\<br>        (x^{(m)})^T\\<br>        \end{pmatrix}\in R^{m*(n+1)}<br>$$<br>$$y=<br>        \begin{pmatrix}<br>        y^{(1)} \\<br>        y^{(2)} \\<br>        y^{(3)} \\<br>        \vdots \\<br>        y^{(m)} \\<br>        \end{pmatrix}\in R^{m}<br>$$<br>$$\overrightarrow{\theta} = (X^TX)^{-1}X^Ty$$<br>求出的$\overrightarrow{\theta}$值即为多元线性回归求出的值。</p><h1 id="三、逻辑回归-Logistic-Regression"><a href="#三、逻辑回归-Logistic-Regression" class="headerlink" title="三、逻辑回归(Logistic Regression)"></a>三、逻辑回归(Logistic Regression)</h1><h2 id="1-假设函数-Hypothesis-2"><a href="#1-假设函数-Hypothesis-2" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x)=estimate\ probability\ that\ y=1\ on\ input\ x$$<br>$$h_\theta(x)=g(\theta^Tx)$$<br>$$g(z)=\frac{1}{1+e^{-z}}(sigmoid\ function)$$<br>$$h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$$</p><h2 id="2-参数-Parameters-2"><a href="#2-参数-Parameters-2" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1,…,\theta_n $$</p><h2 id="3-代价函数-Cost-Function-2"><a href="#3-代价函数-Cost-Function-2" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$ J(\theta_0,\theta_1,..,\theta_n) = \frac{1}{m}\sum_{i=1}^{m}\frac{1}{2}(h_\theta(x^{(i)}) - y^{(i)})^2 =\frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y^{(i)})$$<br>其中，<br>$$Cost(h_\theta(x^{(i)}),y^{(i)})=<br>\begin{cases}<br>-log(h_\theta(x)),&amp;\text{if $y$ = 1} \\<br>-log(1-h_\theta(x)),&amp;\text{if $y$ = 0}<br>\end{cases}<br>$$<br>$$Cost(h_\theta(x^{(i)}),y^{(i)})=-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))$$<br>所以，<br>$$J(\overrightarrow{\theta})=-\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}log\ h_\theta(x^{(i)})+(1-y^{(i)})log\ (1-h_\theta(x^{(i)}))]$$</p><h2 id="4-目标-Goals-2"><a href="#4-目标-Goals-2" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>(1)$$\min_{\theta}J(\theta)$$<br>(2)$$Output\ h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}$$<br>$$P(y=1|x;\theta)$$</p><h2 id="5-解决算法-Solutions-2"><a href="#5-解决算法-Solutions-2" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法"><a href="#1-梯度下降算法" class="headerlink" title="(1).梯度下降算法"></a>(1).梯度下降算法</h3><p>Repeat{<br>&emsp;$\theta_j:=\theta_j-\alpha\frac{∂}{∂\theta_j}J(\theta)$<br>&emsp;(simultaneously update all $\theta_j$)<br>}<br>化简之后可得，<br>Repeat{<br>&emsp;$\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_{j}^{(i)}$<br>&emsp;(simultaneously update all $\theta_j$)<br>}</p><h3 id="2-高级优化算法-Advanced-Optimization"><a href="#2-高级优化算法-Advanced-Optimization" class="headerlink" title="(2).高级优化算法(Advanced Optimization)"></a>(2).高级优化算法(Advanced Optimization)</h3><p>Example:<br>$$\theta=<br>\begin{pmatrix}<br>\theta_1\\<br>\theta_2\\<br>\end{pmatrix}$$<br>$$J(\theta)=(\theta_1-5)^2+(\theta_2-5)^2$$<br>$$\frac{∂}{∂\theta_1}J(\theta) = 2(\theta_1-5)$$<br>$$\frac{∂}{∂\theta_2}J(\theta) = 2(\theta_2-5)$$<br>costFunction函数代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function [jVal,gradient]</span><br><span class="line">            =costFunction(theta)</span><br><span class="line">    jVal = (theta(1)-5)^2+(theta(2)-5)^2;</span><br><span class="line">    gradient = zeros(2,1);</span><br><span class="line">    gradient(1) = 2*(theta(1)-5);</span><br><span class="line">    gradient(2) = 2*(theta(2)-5);</span><br></pre></td></tr></table></figure></p><p>命令行代码：<br>建立设置集合：<br><code>options = optimset(&#39;GraObj&#39;,&#39;on&#39;,&#39;MaxIter&#39;,&#39;100&#39;);</code><br>设置初试theta数组:<br><code>initialTheta = zeros(2,1);</code><br>调用函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[optTheta,functionVal,exitFlag]</span><br><span class="line">            = fminunc(@costFunction,initialTheta,options);</span><br></pre></td></tr></table></figure></p><p>costFunction的通用代码：<br>$$\theta=<br>\begin{pmatrix}<br>\theta_1\\<br>\theta_2\\<br>\vdots\\<br>\theta_n\\<br>\end{pmatrix}$$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function [jVal,gradient]</span><br><span class="line">            =costFunction(theta)</span><br><span class="line">    jVal = [code to compute J(theta)];</span><br><span class="line">    gradient = zeros(n+1,1);</span><br><span class="line">    gradient(1) = [code to compute ∂/∂theta(0)J(theta)];</span><br><span class="line">    gradient(2) = [code to compute ∂/∂theta(1)J(theta)];</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    gradient(n+1) = [code to compute ∂/∂theta(n)J(theta)];</span><br></pre></td></tr></table></figure></p><h2 id="6-多个分类-Multi-Class-Classification-one-vs-all"><a href="#6-多个分类-Multi-Class-Classification-one-vs-all" class="headerlink" title="6.多个分类(Multi-Class Classification:one-vs-all):"></a>6.多个分类(Multi-Class Classification:one-vs-all):</h2><p>y=1,2,3,4,…<br>$$h_\theta^{(i)}(x)=P(y=i|x;\theta)(i=1,2,3,…)$$</p><h1 id="四、正则化线性回归-Regularized-Linear-Regression"><a href="#四、正则化线性回归-Regularized-Linear-Regression" class="headerlink" title="四、正则化线性回归(Regularized Linear Regression)"></a>四、正则化线性回归(Regularized Linear Regression)</h1><h2 id="1-假设函数-Hypothesis-3"><a href="#1-假设函数-Hypothesis-3" class="headerlink" title="1.假设函数(Hypothesis):"></a>1.假设函数(Hypothesis):</h2><p>$$ h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + …+\theta_nx_n$$</p><h2 id="2-参数-Parameters-3"><a href="#2-参数-Parameters-3" class="headerlink" title="2.参数(Parameters):"></a>2.参数(Parameters):</h2><p>$$ \theta_0,\theta_1,…,\theta_n $$</p><h2 id="3-代价函数-Cost-Function-3"><a href="#3-代价函数-Cost-Function-3" class="headerlink" title="3.代价函数(Cost Function):"></a>3.代价函数(Cost Function):</h2><p>$$J(\theta)=\frac{1}{2m}[\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^n\theta_j^2]$$</p><h2 id="4-目标-Goals-3"><a href="#4-目标-Goals-3" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$\min_{\theta}J(\theta)$$</p><h2 id="5-解决算法-Solutions-3"><a href="#5-解决算法-Solutions-3" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-1"><a href="#1-梯度下降算法-1" class="headerlink" title="(1).梯度下降算法"></a>(1).梯度下降算法</h3><p>Repeat{<br>&emsp;$\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}$<br>&emsp;$\theta_j:=\theta_j-\alpha[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_{j}^{(i)}+\frac{\lambda}{m}{\theta_j}]$<br>&emsp;(simultaneously update all $\theta_j$)<br>}<br>$\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$</p><h3 id="2-正规方程-Normal-Equation-1"><a href="#2-正规方程-Normal-Equation-1" class="headerlink" title="(2).正规方程(Normal Equation)"></a>(2).正规方程(Normal Equation)</h3><p>m examples($x^{(1)},y^{(1)}$),…,($x^{(m)},y^{(m)}$),n features.<br>$$x^{(i)}=<br>        \begin{pmatrix}<br>        x_{0}^{(i)} \\<br>        x_{1}^{(i)} \\<br>        x_{2}^{(i)}\\<br>        \vdots \\<br>        x_{n}^{(i)}\\<br>        \end{pmatrix}\in R^{n+1}<br>$$<br>$$X=<br>\begin{pmatrix}<br>(x^{(1)})^T \\<br>\vdots\\<br>(x^{(m)})^T \\<br>\end{pmatrix}<br>$$<br>$$y=<br>        \begin{pmatrix}<br>        y^{(1)} \\<br>        \vdots \\<br>        y^{(m)} \\<br>        \end{pmatrix}\in R^{m}<br>$$<br>if $\lambda&gt;0$,<br>$$\overrightarrow{\theta} = (X^TX+\lambda<br>\begin{pmatrix}<br>0\\<br>&amp;1\\<br>&amp;&amp;1\\<br>&amp;&amp;&amp;\ddots\\<br>&amp;&amp;&amp;&amp;1<br>\end{pmatrix}<br>)^{-1}X^Ty$$</p><h1 id="五、正则化逻辑回归-Regularized-Logistic-Regression"><a href="#五、正则化逻辑回归-Regularized-Logistic-Regression" class="headerlink" title="五、正则化逻辑回归(Regularized Logistic Regression)"></a>五、正则化逻辑回归(Regularized Logistic Regression)</h1><h2 id="1-假设函数-Hypothesis-4"><a href="#1-假设函数-Hypothesis-4" class="headerlink" title="1.假设函数(Hypothesis)"></a>1.假设函数(Hypothesis)</h2><p>$$h_\theta(x)=g(z),z=f(x,\theta)$$</p><h2 id="2-参数-Parameters-4"><a href="#2-参数-Parameters-4" class="headerlink" title="2.参数(Parameters)"></a>2.参数(Parameters)</h2><p>$$\theta_1,\theta_2,…,\theta_n$$</p><h2 id="3-代价函数-Cost-Function-4"><a href="#3-代价函数-Cost-Function-4" class="headerlink" title="3.代价函数(Cost Function)"></a>3.代价函数(Cost Function)</h2><p>$$J(\theta)=-[\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}\log{h_\theta(x^{(i)})}+(1-y^{(i)})\log{(1-h_\theta(x^{(i)})})]+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta^2_j$$</p><h2 id="4-目标-Goals-4"><a href="#4-目标-Goals-4" class="headerlink" title="4.目标(Goals):"></a>4.目标(Goals):</h2><p>$$\min_{\theta}J(\theta)$$</p><h2 id="5-解决算法-Solutions-4"><a href="#5-解决算法-Solutions-4" class="headerlink" title="5.解决算法(Solutions):"></a>5.解决算法(Solutions):</h2><h3 id="1-梯度下降算法-2"><a href="#1-梯度下降算法-2" class="headerlink" title="(1).梯度下降算法"></a>(1).梯度下降算法</h3><p>Repeat{<br>&emsp;$\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}$<br>&emsp;$\theta_j:=\theta_j-\alpha[\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_{j}^{(i)}+\frac{\lambda}{m}{\theta_j}]$<br>&emsp;(simultaneously update all $\theta_j$)<br>}<br>$\theta_j:=\theta_j(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$<br>(2)高级优化算法(Advanced Optimization)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function [jVal,gradient]</span><br><span class="line">            =costFunction(theta)</span><br><span class="line">    jVal = [code to compute J(theta)];</span><br><span class="line">    gradient = zeros(n+1,1);</span><br><span class="line">    gradient(1) = [code to compute ∂/∂theta(0)J(theta)];</span><br><span class="line">    gradient(2) = [code to compute ∂/∂theta(1)J(theta)];</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    gradient(n+1) = [code to compute ∂/∂theta(n)J(theta)];</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、单变量线性回归-Linear-Regression-with-One-Variable&quot;&gt;&lt;a href=&quot;#一、单变量线性回归-Linear-Regression-with-One-Variable&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="http://blog.ijunyu.top/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <link href="http://blog.ijunyu.top/2018/07/22/buildingMyBlogs/"/>
    <id>http://blog.ijunyu.top/2018/07/22/buildingMyBlogs/</id>
    <published>2018-07-22T03:36:21.000Z</published>
    <updated>2018-07-22T08:03:59.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Hexo搭建个人博客"><a href="#利用Hexo搭建个人博客" class="headerlink" title="利用Hexo搭建个人博客"></a>利用Hexo搭建个人博客</h1><p>&emsp;&emsp;Hexo是高效的静态站点生成框架，基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。  </p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-使用工具"><a href="#1-使用工具" class="headerlink" title="1.使用工具"></a>1.使用工具</h3><ul><li>GitHub</li><li>Node.js</li><li>Hexo</li></ul><h3 id="2-本文使用环境"><a href="#2-本文使用环境" class="headerlink" title="2.本文使用环境"></a>2.本文使用环境</h3><ul><li>Windows 10 version 1803</li><li>Git for Windows version 2.17.0</li><li>Node.js version 10.5.0</li><li>Hexo version 3.7.1</li></ul><h3 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3.环境搭建"></a>3.环境搭建</h3><h4 id="1-搭建Node-js环境"><a href="#1-搭建Node-js环境" class="headerlink" title="(1)搭建Node.js环境"></a>(1)搭建Node.js环境</h4><p>&emsp;&emsp;Hexo基于Node.js，Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用，所以先搭建Node.js环境。<br><a href="http://nodejs.cn/download" target="_blank" rel="noopener">Node.js下载地址</a><br><img src="https://i.imgur.com/es0Yi0k.png" alt=""><br>&emsp;&emsp;可以根据自己的需要下载对应的版本，Windows系统下载扩展名为.msi的文件安装即可。<br>&emsp;&emsp;安装完成后在命令行下输入  <code>node -v</code>，如果出现对应的版本号则说明安装成功。<br>新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 <code>npm -v</code> 来测试是否成功安装，出现版本提示表示安装成功:  </p><h4 id="2-安装Git版本工具"><a href="#2-安装Git版本工具" class="headerlink" title="(2)安装Git版本工具"></a>(2)安装Git版本工具</h4><p>&emsp;&emsp;Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。<br><a href="https://git-scm.com/download/" target="_blank" rel="noopener">Git下载地址</a><br>&emsp;&emsp;下载完成后按默认配置安装即可，安装完成后命令行输入 <code>git --version</code>,如果出现对应的版本号则说明安装成功。<br>&emsp;&emsp;安装成功后可以在开始菜单中找到名为git bash的应用图标，此为git的命令行形式，关于hexo的操作今后无特殊说明都是在gitbash下进行。 </p><h4 id="3-注册GitHub账号"><a href="#3-注册GitHub账号" class="headerlink" title="(3)注册GitHub账号"></a>(3)注册GitHub账号</h4><p>&emsp;&emsp;GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。<br><a href="https://github.com" target="_blank" rel="noopener">GitHub注册地址</a><br>&emsp;&emsp;GitHub为英文网站，可以根据提示进行注册操作，如果有不明白的地方可以百度解决，这里要注意的是用户名作为Git上很重要的标识，起名字的时候一定要选择一个合适的名字,我的用户名是zhangjy982，所以进入我个人GitHub的地址为:https:github.com/zhangjy982,下附链接：<a href="https://github.com/zhangjy982" target="_blank" rel="noopener">张俊余的GitHub</a>。  </p><h4 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="(4)安装hexo"></a>(4)安装hexo</h4><p>&emsp;&emsp;前面已经说过，在安装node.js的时候已经将npm集成进去，如果之前测试npm集成成功的话，hexo的安装只需要在gitbash中输入：<br><code>npm install -g hexo</code><br>&emsp;&emsp;等待自动完成后，输入<code>hexo version</code>可以查看hexo对应版本以及判断hexo是否安装成功。</p><h2 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h3><p>&emsp;&emsp;在前面的准备工作中我们已经注册过GitHub账号，接下来要进行的就是在GitHub中创建博客存储的仓库：<br>&emsp;&emsp;第一步，点击新建仓库（new repository）:<br><img src="https://i.imgur.com/1dZ1v7s.png" alt=""><br>&emsp;&emsp;第二步，填写仓库信息，这里最重要的是仓库的名字，要和你的用户名一致，名字的格式为：<code>username.github.io</code>，我为了写这个博客重新注册了一个Git账号：zhangjytest，所以我的仓库名字应该为：<code>zhangjytest.github.io</code>，这样的目的是确定访问地址，以后如果不绑定域名，博客的访问地址就是zhangjytest.github.io了，每个GitHub账户只能创建一个直接使用域名访问的仓库：<br><img src="https://i.imgur.com/4iSlMrT.png" alt=""></p><h3 id="2-配置本地gitbash账户信息"><a href="#2-配置本地gitbash账户信息" class="headerlink" title="2.配置本地gitbash账户信息"></a>2.配置本地gitbash账户信息</h3><p>&emsp;&emsp;为了可以使本地文件上传到Git，需要在gitbash中进行账户信息配置，配置过程如下：<br>&emsp;&emsp;第一步，账户配置，在gitbash下分别输入如下代码：<br><code>git config --global user.name &quot;your name&quot;</code><br><code>git config --global user.email &quot;your email&quot;</code><br><img src="https://i.imgur.com/JY9U7Ft.png" alt=""><br>第二步，创建SSH，在gitbash下输入：<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code><br><img src="https://i.imgur.com/GCGsmsZ.png" alt=""><br>&emsp;&emsp;执行过程中一直按回车键完成执行，执行完毕后会在”C:\Users\zhangjy982.ssh”（zhangjy982为我个人的用户名）文件夹下生成两个文件，分别为<code>id_rsa</code>和<code>id_rsa.pub</code>，用记事本打开<code>id_rsa.pub</code>文件，复制其中全部内容。<br>&emsp;&emsp;第三步，将获取的SSH设置到GitHub中：<br>&emsp;&emsp;进入设置页面：<br><img src="https://i.imgur.com/fvGl6ES.png" alt=""><br>&emsp;&emsp;在设置中找到SSH and GPG keys中的add SSH，将复制下来的字符串复制到Key中，Title值可以是任意值：<br><img src="https://i.imgur.com/Goc53dv.png" alt=""><br>&emsp;&emsp;第四步，在gitbash中验证是否成功：<br><code>ssh -T git@github.com</code><br>&emsp;&emsp;如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes后如下图所示：<br><img src="https://i.imgur.com/UqTrTAI.png" alt=""><br>&emsp;&emsp;此时gitbash的配置也已经完成。</p><h3 id="2-利用hexo写博客"><a href="#2-利用hexo写博客" class="headerlink" title="2.利用hexo写博客"></a>2.利用hexo写博客</h3><p>&emsp;&emsp;第一步，安装过程已经在环境搭建步骤中完成。<br>&emsp;&emsp;第二步，初始化，在你想要存放本地blog文件的地方新建文件夹MyBlogs（文件名字可任意），比如我的是C：\Users\zhangjy982\MyBlogs,先进入文件夹:<code>cd &quot;C:\Users\zhangjy982\MyBlogs&quot;</code>,<br><img src="https://i.imgur.com/mzqZFRu.png" alt=""><br>&emsp;&emsp;然后输入：<code>hexo init</code>,hexo就会自动下载一些到该文件夹，过程可能稍慢，耐心等待，<br><img src="https://i.imgur.com/nrtHsCI.png" alt=""><br>文件夹解释:  </p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息<br>&emsp;&emsp;第三步，提交到服务器，<code>hexo s</code>命令可以启动本地localhost服务，默认启动4000端口，启动后如图，Ctrl+C可以关闭服务。<br><img src="https://i.imgur.com/OfyqIJI.png" alt=""><br>&emsp;&emsp;第四步，打开浏览器，地址栏输入：<code>http://localhost:4000</code>,即可展示默认的博客界面，默认博客已经有一篇helloworld的博客，所以效果是下面这样的，如果你出现了下面这个页面，说明你已经成功了一大半了。<br><img src="https://i.imgur.com/6cvi5IK.png" alt=""><br>&emsp;&emsp;第五步，到目前为止，呈现出的网页还是本地的，那么如何上传到GitHub，继而可以通过域名访问呢，很简单，只需要几个简单的命令就可以，我们首先先介绍一下常用的几个命令：<br>(1)<code>hexo g</code><br>此命令可以生成静态页面到public文件夹；<br>(2)<code>hexo d</code><br>此命令可以将静态页面部署到服务器端，进而可以实现域名访问；<br>(3)<code>hexo g -d</code><br>此命令可以完成生成静态页面后部署到服务器的全过程；<br>(4)<code>hexo d -g</code><br>此命令是部署之前预先生成静态文件；<br>(5)<code>hexo clean</code><br>此命令是将之前生成的静态页面删除，适用于更改配置文件之后重新生成静态文件之前的操作，可以把旧的静态文件删除；<br>&emsp;&emsp;除此之外，还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：<br><img src="https://i.imgur.com/pxZayiF.png" alt=""><br>&emsp;&emsp;然后修改本地博客目录的配置，即修改_config.yml文件，修改yml文件的时候需注意utf-8的格式要求，写字板和记事本等软件会改变文件的编码格式，建议使用sublime等工具，修改deploy配置如下：<br><img src="https://i.imgur.com/4mkVMYJ.png" alt=""><br>&emsp;&emsp;保存完配置文件之后，随后需要安装部署插件：<code>npm install hexo-deployer-git —save</code><br>最后，在gitbash下直接输入<code>hexo clean</code>可以将博客之前生成的静态页面清楚，然后输入<code>hexo g -d</code>完成博客上传，以实现域名访问，此时的访问域名为<code>zhangjytest.github.io</code> 得到的页面和之前的本地访问页面是一致的。 <h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2>&emsp;&emsp;本文主要介绍了hexo搭建个人博客的最基础的过程，至此，已经完成了博客的初步搭建，但是后续还有写新博客，博客主题更改，博客文章分类，博客访问人数统计，博客字数展示，博客阅读时间估计等基本内容，后续的文章中会继续介绍整个过程。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用Hexo搭建个人博客&quot;&gt;&lt;a href=&quot;#利用Hexo搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;利用Hexo搭建个人博客&quot;&gt;&lt;/a&gt;利用Hexo搭建个人博客&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Hexo是高效的静态站点生成框架，基
      
    
    </summary>
    
      <category term="技术" scheme="http://blog.ijunyu.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://blog.ijunyu.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Octive基本操作</title>
    <link href="http://blog.ijunyu.top/2018/07/20/Octive/"/>
    <id>http://blog.ijunyu.top/2018/07/20/Octive/</id>
    <published>2018-07-20T11:48:53.000Z</published>
    <updated>2018-07-20T14:44:11.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Octive基本操作"><a href="#Octive基本操作" class="headerlink" title="Octive基本操作"></a>Octive基本操作</h1><h2 id="一、基本运算"><a href="#一、基本运算" class="headerlink" title="一、基本运算"></a>一、基本运算</h2><h3 id="1-基本四则运算"><a href="#1-基本四则运算" class="headerlink" title="1.基本四则运算"></a>1.基本四则运算</h3><p>(1)5+6<br>加法运算，ans = 11；<br>(2)6-9<br>减法运算，ans = -3；<br>(3)65*8<br>乘法运算，ans = 520；<br>(4)23/8<br>除法运算，ans = 2.87500000000000；<br>(5)4^6<br>乘方运算，ans = 4096；<br>(6)sqrt(10)<br>平方根运算，ans = 3.16227766016838；</p><h3 id="2-逻辑运算"><a href="#2-逻辑运算" class="headerlink" title="2.逻辑运算"></a>2.逻辑运算</h3><p>(1)1 == 2<br>判断相等，ans = 0；<br>(2)1 ~=2<br>判断不等，ans = 1；<br>(3)1 &amp;&amp; 0<br>判断逻辑与，ans = 0；<br>(4)1 || 0<br>判断逻辑或，ans = 1；<br>(5)xor(1,0)<br>判断异或，ans = 1；</p><h2 id="二、基本函数"><a href="#二、基本函数" class="headerlink" title="二、基本函数"></a>二、基本函数</h2><p>(1)disp(a)<br>展示变量信息；<br>(2)disp(sprintf(‘2 decimals: %0.2f’,a))：<br>显示字符串变量，其中格式和c类似；<br>(3)PS1(‘&gt;&gt; ‘)<br>更改左边显示样式；<br>(4)format long/short<br>数据格式更改；<br>(5)hist(w)<br>将矩阵表示的分布用直方图显示出来，其中w为服从高斯分布的数据组成的矩阵;<br>(6)hist(w,50)<br>可以指定生成的直方图的方格的数量；</p><h2 id="三、矩阵表示"><a href="#三、矩阵表示" class="headerlink" title="三、矩阵表示"></a>三、矩阵表示</h2><h3 id="1-普通表示"><a href="#1-普通表示" class="headerlink" title="1.普通表示"></a>1.普通表示</h3><p>(1)A = [1 2;3 4;5 6]<br>表示一个3x2的矩阵，分号表示一行；</p><h3 id="2-行向量表示"><a href="#2-行向量表示" class="headerlink" title="2.行向量表示"></a>2.行向量表示</h3><p>(1)V = 1：0.1：2<br>表示从1开始每次增加0.1，最大到2的行向量；<br>(2)V = 1：6<br>表示1 2 3 4 5 6组成的行向量；</p><h3 id="3-特殊函数表示"><a href="#3-特殊函数表示" class="headerlink" title="3.特殊函数表示"></a>3.特殊函数表示</h3><p>(1)W = ones（2，3）<br>表示只包含1的一个2行3列矩阵；<br>(2)W = 2*ones（2，3）<br>表示只包含2的2行3列矩阵；<br>(3)W = rand（1，3）<br>表示包含0-1之间随机小数的1行3列矩阵；<br>(4)W = randn（2，3）<br>表示服从高斯分布，标准差或者方差为1的数据组成的2行3列矩阵；</p><h3 id="4-单位矩阵表示"><a href="#4-单位矩阵表示" class="headerlink" title="4.单位矩阵表示"></a>4.单位矩阵表示</h3><p>(1).E = eye（4）表示生成4x4的单位矩阵；</p><h2 id="四、移动数据"><a href="#四、移动数据" class="headerlink" title="四、移动数据"></a>四、移动数据</h2><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h3><p>(1)size(A)<br>返回矩阵A的各个维度数目的行向量，ans = 3 2；<br>(2)size(A,1)<br>返回矩阵A的第一维数目，ans = 3；<br>(3)size(A,2)<br>返回矩阵A的第二维数目，ans = 2；<br>(4)length(V)<br>返回矩阵的各个维度中的最大值，通常用于返回向量的维度值，ans = 4；<br>(5)load featuresX.dat<br>加载数据文件，加载完成后生成与文件名相同名字的变量；<br>(5)load(‘featuresX.dat’)<br>加载数据文件的另一种方法；<br>(6)who<br>显示所有变量；<br>(7)whos<br>显示所有变量及其详细信息；<br>(8)clear featuresX<br>删除变量；<br>(9)v = featuresX(1:10)<br>将featuresX中第一列数据的1-10个赋值给变量v；<br>(10)save hello.mat v<br>使变量v保存为一个名为hello.mat的文件，该文件使用二进制压缩的方式存储；<br>(11)clear<br>删除当前工作空间中的所有变量；<br>(12)load hello.mat<br>加载之前生成的文件，加载完成后变量v重新自动出现；<br>(13)save hello.txt v -ascii<br>将变量v保存为一个名为hello.txt的文本文件；</p><h3 id="2-数据获取及移动（A-1-2-3-4-5-6-）"><a href="#2-数据获取及移动（A-1-2-3-4-5-6-）" class="headerlink" title="2.数据获取及移动（A = [1 2 ; 3 4 ; 5 6]）"></a>2.数据获取及移动（A = [1 2 ; 3 4 ; 5 6]）</h3><p>(1) A(3,2)<br>返回矩阵A第三行第二列的元素，ans = 6；<br>(2)A(2,:)<br>返回第二行所有元素；<br>(3)A(:,2)<br>返回第二列所有元素；<br>(4)A([1 3],:)<br>返回第一行和第三行所有元素；<br>(5)A(:,2) = [10;11;12]<br>将矩阵A的第二列重新赋值；<br>(6)A = (A,[100;101;102])<br>为矩阵A增加一列新的向量；<br>(7)A = (A;[1 3])<br>为矩阵A增加一行新的向量；<br>(8)A(:)<br>将矩阵A中的所有元素形成一个列向量；<br>(9)C = [A B]<br>将矩阵A与矩阵B横向合并；<br>(10)C = [A,B]<br>将矩阵A与矩阵B横向合并；<br>(11)C = [A;B]<br>将矩阵A与矩阵B纵向合并；</p><h2 id="五、矩阵数据计算"><a href="#五、矩阵数据计算" class="headerlink" title="五、矩阵数据计算"></a>五、矩阵数据计算</h2><h3 id="1-矩阵基本运算-A-1-2-3-4-5-6-v-1-15-2-0-5"><a href="#1-矩阵基本运算-A-1-2-3-4-5-6-v-1-15-2-0-5" class="headerlink" title="1.矩阵基本运算(A  = [1 2 ;3 4;5 6],v = [1 15 2 0.5])"></a>1.矩阵基本运算(A  = [1 2 ;3 4;5 6],v = [1 15 2 0.5])</h3><p>(1)A <em> B<br>矩阵乘法，按照正常的矩阵乘法流程运算，运算结果是线性代数矩阵相乘结果；<br>(2)A .</em> B<br>矩阵A和矩阵B的各项分别相乘，必须是同型矩阵才可以相乘，点号通常用于表示元素之间的运算；<br>(3)A .^ 2<br>矩阵A中的每一个元素都做乘方2的运算；<br>(4)1 ./ A<br>矩阵A中的每一个元素都取倒数；<br>(5)log(A)<br>矩阵A中的每一个元素取log值；<br>(6)exp(A)<br>以e为底数，A中元素为指数的幂运算，结果仍为矩阵；<br>(7)abs(A)<br>将矩阵A中的每一个元素都取其绝对值，结果仍为矩阵；<br>(8)-A<br>将矩阵中的每一个元素都取其相反数，结果仍为矩阵；<br>(9)v + ones(length(v),1)<br>将v中的每一个元素都加1；<br>(10)v + 1<br>将v中的每一个元素都加1；<br>(11)A’<br>A的转置；<br>(12)A&lt;3<br>将矩阵A中的每一个元素和3比较如果满足小于3的条件置一，否则置零，最后形成一个和A同型的矩阵，<br>矩阵的每个元素是0或者1；</p><h3 id="2-矩阵运算中的部分重要函数-A-magic-4"><a href="#2-矩阵运算中的部分重要函数-A-magic-4" class="headerlink" title="2.矩阵运算中的部分重要函数(A=magic(4))"></a>2.矩阵运算中的部分重要函数(A=magic(4))</h3><p>(1)magic(4)<br>生成一个幻方矩阵，幻方矩阵的特点的特点是每一行、每一列和对角线上的元素加起来数值相等；<br>(2)max函数<br>a.[val,ind] = max(A)<br>val返回每一列中最大的元素值，并组成一个行向量，ind返回最大元素值的索引值，并组成一个行向量；<br>b.max(A,[],1)<br>返回每一列中的最大元素值，并组成一个行向量；<br>c.max(A,[],2)<br>返回每一行中的最大元素值，并组成一个列向量；<br>d.val = max(A)<br>将val赋值为每一列最大值组成的行向量；<br>e.max(max(A))<br>返回矩阵中的最大值；<br>f.max(A(:))<br>先将矩阵A中的所有元素转为列向量之后取最大值，也是起到取矩阵最大值的效果；<br>(3)find(A&lt;3)<br>返回矩阵A 中元素值小于3的索引，产生顺序为按照列进行，结果为一个列向量；<br>(4)[r,c] = find(A&lt;=7)<br>查找矩阵A 中小于等于7的所有元素的索引，r为行索引，c为列索引，查找顺序按照列进行；<br>(5)sum函数<br>a.sum(A)<br>将矩阵A中每一列的元素值求和，返回求和值组成的一个行向量，向量维度和A的列数相等；<br>b.sum(A,1)<br>将矩阵A中每一列的元素值求和，返回求和值组成的一个行向量，向量维度和A的列数相等；<br>c.sum(A,2)<br>将矩阵A中每一行的元素值求和，返回求和值组成的一个列向量，向量维度和A的行数相等；<br>d.sum(sum(A .<em> eye(4)))<br>返回矩阵A正对角线元素之和；<br>e.sum(sum(A .</em>flipud(eye(4))))<br>返回矩阵A反对角线元素之和；<br>(6)flipud(A)<br>使矩阵A垂直翻转，即最后一行变成第一行，倒数第二行变成第二行，倒数第三行变成第三行，以此类推；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Octive基本操作&quot;&gt;&lt;a href=&quot;#Octive基本操作&quot; class=&quot;headerlink&quot; title=&quot;Octive基本操作&quot;&gt;&lt;/a&gt;Octive基本操作&lt;/h1&gt;&lt;h2 id=&quot;一、基本运算&quot;&gt;&lt;a href=&quot;#一、基本运算&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.ijunyu.top/2018/07/06/hello-world/"/>
    <id>http://blog.ijunyu.top/2018/07/06/hello-world/</id>
    <published>2018-07-06T13:53:01.050Z</published>
    <updated>2018-09-20T06:11:56.744Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: [Deployment](<a href="https://hexo.io/docs/deployment" target="_blank" rel="noopener">https://hexo.io/docs/deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
